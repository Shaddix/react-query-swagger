//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.19.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming
import * as Types from '../axios-client';
import { useQuery, useMutation } from '@tanstack/vue-query';
import type { UseQueryReturnType, QueryFunctionContext, UseQueryOptions, QueryClient, QueryKey, MutationKey, UseMutationOptions, UseMutationReturnType, QueryMeta, MutationMeta } from '@tanstack/vue-query';
type MaybeRef<T> = Ref<T> | T;
type NoRef<C> = C extends Ref<infer T> ? T : C;
type NoRefObject<T> = {
  [P in keyof T]: NoRef<T[P]>;
};
import { trimArrayEnd, isParameterObject, getBaseUrl, addMetaToOptions } from './helpers';
import type { Ref } from 'vue';
import * as Client from './Client'
export { Client };
import type { AxiosRequestConfig } from 'axios';

export type UploadFileQueryParameters = {
  petId: MaybeRef<number> ;
  additionalMetadata: MaybeRef<string | null | undefined> ;
  file: MaybeRef<Types.FileParameter | null | undefined> ;
}

export type UploadFileMutationParameters = {
  additionalMetadata: string | null | undefined ;
  file: Types.FileParameter | null | undefined ;
}

export type FindPetsByStatusQueryParameters = {
  status: MaybeRef<Types.Status[]> ;
}

export type FindPetsByTagsQueryParameters = {
  tags: MaybeRef<string[]> ;
}

export type GetPetByIdQueryParameters = {
  petId: MaybeRef<number> ;
}

export type UpdatePetWithFormQueryParameters = {
  petId: MaybeRef<number> ;
  name: MaybeRef<string | null | undefined> ;
  status: MaybeRef<string | null | undefined> ;
}

export type UpdatePetWithFormMutationParameters = {
  name: string | null | undefined ;
  status: string | null | undefined ;
}

export type DeletePetQueryParameters = {
  api_key: MaybeRef<string | null | undefined> ;
  petId: MaybeRef<number> ;
}

export type GetOrderByIdQueryParameters = {
  orderId: MaybeRef<number> ;
}

export type DeleteOrderQueryParameters = {
  orderId: MaybeRef<number> ;
}


export type GetUserByNameQueryParameters = {
  username: MaybeRef<string> ;
}

export type UpdateUserQueryParameters = {
  username: MaybeRef<string> ;
}

export type DeleteUserQueryParameters = {
  username: MaybeRef<string> ;
}

export type LoginUserQueryParameters = {
  username: MaybeRef<string> ;
  password: MaybeRef<string> ;
}

export function uploadFileUrl(petId: number): string {
  let url_ = getBaseUrl() + "/pet/{petId}/uploadImage";
if (petId === undefined || petId === null)
  throw new Error("The parameter 'petId' must be defined.");
url_ = url_.replace("{petId}", encodeURIComponent("" + petId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function uploadFileMutationKey(petId: MaybeRef<number>): MutationKey {
  return trimArrayEnd([
      'Client',
      'uploadFile',
      petId as any,
    ]);
}

/**
 * uploads an image
 * @param petId ID of pet to update
 * @param additionalMetadata (optional) Additional data to pass to server
 * @param file (optional) file to upload
 * @return successful operation
 */
export function useUploadFileMutation<TContext>(petId: MaybeRef<number>, options?: Omit<UseMutationOptions<Types.ApiResponse, unknown, UploadFileMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationReturnType<Types.ApiResponse, unknown, UploadFileMutationParameters, TContext> {
  const key = uploadFileMutationKey(petId);
  
  return useMutation((uploadFileMutationParameters: UploadFileMutationParameters) => Client.uploadFile(petId as any, uploadFileMutationParameters.additionalMetadata as any, uploadFileMutationParameters.file as any), {...options, mutationKey: key});
}
  
type UploadFile__MutationParameters = UploadFileQueryParameters & {
  uploadFileMutationParameters: UploadFileMutationParameters;
}

/**
 * uploads an image
 * @param petId ID of pet to update
 * @param additionalMetadata (optional) Additional data to pass to server
 * @param file (optional) file to upload
 * @return successful operation
 */
export function useUploadFileMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.ApiResponse, unknown, NoRefObject<UploadFile__MutationParameters>, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: UploadFileQueryParameters}): UseMutationReturnType<Types.ApiResponse, unknown, NoRefObject<UploadFile__MutationParameters>, TContext> {
  const key = uploadFileMutationKey(options?.parameters?.petId! as any);
  
  return useMutation((data: NoRefObject<UploadFile__MutationParameters>) => Client.uploadFile(data.petId, data.additionalMetadata, data.file), {...options, mutationKey: key});
}
  
export function addPetUrl(): string {
  let url_ = getBaseUrl() + "/pet";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function addPetMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'addPet',
    ]);
}

/**
 * Add a new pet to the store
 * @param body Pet object that needs to be added to the store
 */
export function useAddPetMutation<TContext>(options?: Omit<UseMutationOptions<void, unknown, Types.Pet, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationReturnType<void, unknown, Types.Pet, TContext> {
  const key = addPetMutationKey();
  
  return useMutation((body: Types.Pet) => Client.addPet(body as any), {...options, mutationKey: key});
}
  
export function updatePetUrl(): string {
  let url_ = getBaseUrl() + "/pet";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function updatePetMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'updatePet',
    ]);
}

/**
 * Update an existing pet
 * @param body Pet object that needs to be added to the store
 */
export function useUpdatePetMutation<TContext>(options?: Omit<UseMutationOptions<void, unknown, Types.Pet, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationReturnType<void, unknown, Types.Pet, TContext> {
  const key = updatePetMutationKey();
  
  return useMutation((body: Types.Pet) => Client.updatePet(body as any), {...options, mutationKey: key});
}
  
export function findPetsByStatusUrl(status: Types.Status[]): string {
  let url_ = getBaseUrl() + "/pet/findByStatus?";
  if (status === undefined || status === null)
    throw new Error("The parameter 'status' must be defined and cannot be null.");
  else
    status && status.forEach(item => { url_ += "status=" + encodeURIComponent("" + item) + "&"; });
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let findPetsByStatusDefaultOptions: UseQueryOptions<Types.Pet[], unknown, Types.Pet[]> = {
  queryFn: __findPetsByStatus,
};
export function getFindPetsByStatusDefaultOptions(): UseQueryOptions<Types.Pet[], unknown, Types.Pet[]> {
  return findPetsByStatusDefaultOptions;
};
export function setFindPetsByStatusDefaultOptions(options: UseQueryOptions<Types.Pet[], unknown, Types.Pet[]>) {
  findPetsByStatusDefaultOptions = options;
}

export function findPetsByStatusQueryKey(status: Types.Status[]): QueryKey;
export function findPetsByStatusQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { status,  } = params[0] as FindPetsByStatusQueryParameters;

    return trimArrayEnd([
        'Client',
        'findPetsByStatus',
        status as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'findPetsByStatus',
        ...params
      ]);
  }
}
function __findPetsByStatus(context: QueryFunctionContext) {
  return Client.findPetsByStatus(
      context.queryKey[2] as Types.Status[]    );
}

export function useFindPetsByStatusQuery<TSelectData = Types.Pet[], TError = unknown>(dto: FindPetsByStatusQueryParameters, options?: UseQueryOptions<Types.Pet[], TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryReturnType<TSelectData, TError>;
/**
 * Finds Pets by status
 * @param status Status values that need to be considered for filter
 * @return successful operation
 */
export function useFindPetsByStatusQuery<TSelectData = Types.Pet[], TError = unknown>(status: MaybeRef<Types.Status[]>, options?: UseQueryOptions<Types.Pet[], TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryReturnType<TSelectData, TError>;
export function useFindPetsByStatusQuery<TSelectData = Types.Pet[], TError = unknown>(...params: any []): UseQueryReturnType<TSelectData, TError> {
  let options: UseQueryOptions<Types.Pet[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let status: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ status,  } = params[0] as FindPetsByStatusQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [status, options, axiosConfig] = params;
    }
  }
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.Pet[], TError, TSelectData>({
    queryFn: __findPetsByStatus,
    queryKey: findPetsByStatusQueryKey(status),
    ...findPetsByStatusDefaultOptions as unknown as UseQueryOptions<Types.Pet[], TError, TSelectData>,
    ...options,
  });
}
/**
 * Finds Pets by status
 * @param status Status values that need to be considered for filter
 * @return successful operation
 */
export function setFindPetsByStatusData(queryClient: QueryClient, updater: (data: Types.Pet[] | undefined) => Types.Pet[], status: Types.Status[]) {
  queryClient.setQueryData(findPetsByStatusQueryKey(status),
    updater
  );
}

/**
 * Finds Pets by status
 * @param status Status values that need to be considered for filter
 * @return successful operation
 */
export function setFindPetsByStatusDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.Pet[] | undefined) => Types.Pet[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function findPetsByTagsUrl(tags: string[]): string {
  let url_ = getBaseUrl() + "/pet/findByTags?";
  if (tags === undefined || tags === null)
    throw new Error("The parameter 'tags' must be defined and cannot be null.");
  else
    tags && tags.forEach(item => { url_ += "tags=" + encodeURIComponent("" + item) + "&"; });
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let findPetsByTagsDefaultOptions: UseQueryOptions<Types.Pet[], unknown, Types.Pet[]> = {
  queryFn: __findPetsByTags,
};
export function getFindPetsByTagsDefaultOptions(): UseQueryOptions<Types.Pet[], unknown, Types.Pet[]> {
  return findPetsByTagsDefaultOptions;
};
export function setFindPetsByTagsDefaultOptions(options: UseQueryOptions<Types.Pet[], unknown, Types.Pet[]>) {
  findPetsByTagsDefaultOptions = options;
}

export function findPetsByTagsQueryKey(tags: string[]): QueryKey;
export function findPetsByTagsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { tags,  } = params[0] as FindPetsByTagsQueryParameters;

    return trimArrayEnd([
        'Client',
        'findPetsByTags',
        tags as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'findPetsByTags',
        ...params
      ]);
  }
}
function __findPetsByTags(context: QueryFunctionContext) {
  return Client.findPetsByTags(
      context.queryKey[2] as string[]    );
}

export function useFindPetsByTagsQuery<TSelectData = Types.Pet[], TError = unknown>(dto: FindPetsByTagsQueryParameters, options?: UseQueryOptions<Types.Pet[], TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryReturnType<TSelectData, TError>;
/**
 * Finds Pets by tags
 * @param tags Tags to filter by
 * @return successful operation
 * @deprecated
 */
export function useFindPetsByTagsQuery<TSelectData = Types.Pet[], TError = unknown>(tags: MaybeRef<string[]>, options?: UseQueryOptions<Types.Pet[], TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryReturnType<TSelectData, TError>;
export function useFindPetsByTagsQuery<TSelectData = Types.Pet[], TError = unknown>(...params: any []): UseQueryReturnType<TSelectData, TError> {
  let options: UseQueryOptions<Types.Pet[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let tags: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ tags,  } = params[0] as FindPetsByTagsQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [tags, options, axiosConfig] = params;
    }
  }
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.Pet[], TError, TSelectData>({
    queryFn: __findPetsByTags,
    queryKey: findPetsByTagsQueryKey(tags),
    ...findPetsByTagsDefaultOptions as unknown as UseQueryOptions<Types.Pet[], TError, TSelectData>,
    ...options,
  });
}
/**
 * Finds Pets by tags
 * @param tags Tags to filter by
 * @return successful operation
 * @deprecated
 */
export function setFindPetsByTagsData(queryClient: QueryClient, updater: (data: Types.Pet[] | undefined) => Types.Pet[], tags: string[]) {
  queryClient.setQueryData(findPetsByTagsQueryKey(tags),
    updater
  );
}

/**
 * Finds Pets by tags
 * @param tags Tags to filter by
 * @return successful operation
 * @deprecated
 */
export function setFindPetsByTagsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.Pet[] | undefined) => Types.Pet[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function getPetByIdUrl(petId: number): string {
  let url_ = getBaseUrl() + "/pet/{petId}";
if (petId === undefined || petId === null)
  throw new Error("The parameter 'petId' must be defined.");
url_ = url_.replace("{petId}", encodeURIComponent("" + petId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getPetByIdDefaultOptions: UseQueryOptions<Types.Pet, unknown, Types.Pet> = {
  queryFn: __getPetById,
};
export function getGetPetByIdDefaultOptions(): UseQueryOptions<Types.Pet, unknown, Types.Pet> {
  return getPetByIdDefaultOptions;
};
export function setGetPetByIdDefaultOptions(options: UseQueryOptions<Types.Pet, unknown, Types.Pet>) {
  getPetByIdDefaultOptions = options;
}

export function getPetByIdQueryKey(petId: number): QueryKey;
export function getPetByIdQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { petId,  } = params[0] as GetPetByIdQueryParameters;

    return trimArrayEnd([
        'Client',
        'getPetById',
        petId as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'getPetById',
        ...params
      ]);
  }
}
function __getPetById(context: QueryFunctionContext) {
  return Client.getPetById(
      context.queryKey[2] as number    );
}

export function useGetPetByIdQuery<TSelectData = Types.Pet, TError = unknown>(dto: GetPetByIdQueryParameters, options?: UseQueryOptions<Types.Pet, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryReturnType<TSelectData, TError>;
/**
 * Find pet by ID
 * @param petId ID of pet to return
 * @return successful operation
 */
export function useGetPetByIdQuery<TSelectData = Types.Pet, TError = unknown>(petId: MaybeRef<number>, options?: UseQueryOptions<Types.Pet, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryReturnType<TSelectData, TError>;
export function useGetPetByIdQuery<TSelectData = Types.Pet, TError = unknown>(...params: any []): UseQueryReturnType<TSelectData, TError> {
  let options: UseQueryOptions<Types.Pet, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let petId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ petId,  } = params[0] as GetPetByIdQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [petId, options, axiosConfig] = params;
    }
  }
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.Pet, TError, TSelectData>({
    queryFn: __getPetById,
    queryKey: getPetByIdQueryKey(petId),
    ...getPetByIdDefaultOptions as unknown as UseQueryOptions<Types.Pet, TError, TSelectData>,
    ...options,
  });
}
/**
 * Find pet by ID
 * @param petId ID of pet to return
 * @return successful operation
 */
export function setGetPetByIdData(queryClient: QueryClient, updater: (data: Types.Pet | undefined) => Types.Pet, petId: number) {
  queryClient.setQueryData(getPetByIdQueryKey(petId),
    updater
  );
}

/**
 * Find pet by ID
 * @param petId ID of pet to return
 * @return successful operation
 */
export function setGetPetByIdDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.Pet | undefined) => Types.Pet) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function updatePetWithFormUrl(petId: number): string {
  let url_ = getBaseUrl() + "/pet/{petId}";
if (petId === undefined || petId === null)
  throw new Error("The parameter 'petId' must be defined.");
url_ = url_.replace("{petId}", encodeURIComponent("" + petId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function updatePetWithFormMutationKey(petId: MaybeRef<number>): MutationKey {
  return trimArrayEnd([
      'Client',
      'updatePetWithForm',
      petId as any,
    ]);
}

/**
 * Updates a pet in the store with form data
 * @param petId ID of pet that needs to be updated
 * @param name (optional) Updated name of the pet
 * @param status (optional) Updated status of the pet
 */
export function useUpdatePetWithFormMutation<TContext>(petId: MaybeRef<number>, options?: Omit<UseMutationOptions<void, unknown, UpdatePetWithFormMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationReturnType<void, unknown, UpdatePetWithFormMutationParameters, TContext> {
  const key = updatePetWithFormMutationKey(petId);
  
  return useMutation((updatePetWithFormMutationParameters: UpdatePetWithFormMutationParameters) => Client.updatePetWithForm(petId as any, updatePetWithFormMutationParameters.name as any, updatePetWithFormMutationParameters.status as any), {...options, mutationKey: key});
}
  
type UpdatePetWithForm__MutationParameters = UpdatePetWithFormQueryParameters & {
  updatePetWithFormMutationParameters: UpdatePetWithFormMutationParameters;
}

/**
 * Updates a pet in the store with form data
 * @param petId ID of pet that needs to be updated
 * @param name (optional) Updated name of the pet
 * @param status (optional) Updated status of the pet
 */
export function useUpdatePetWithFormMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, NoRefObject<UpdatePetWithForm__MutationParameters>, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: UpdatePetWithFormQueryParameters}): UseMutationReturnType<void, unknown, NoRefObject<UpdatePetWithForm__MutationParameters>, TContext> {
  const key = updatePetWithFormMutationKey(options?.parameters?.petId! as any);
  
  return useMutation((data: NoRefObject<UpdatePetWithForm__MutationParameters>) => Client.updatePetWithForm(data.petId, data.name, data.status), {...options, mutationKey: key});
}
  
export function deletePetUrl(petId: number, api_key: string | null | undefined): string {
  let url_ = getBaseUrl() + "/pet/{petId}";
if (petId === undefined || petId === null)
  throw new Error("The parameter 'petId' must be defined.");
url_ = url_.replace("{petId}", encodeURIComponent("" + petId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function deletePetMutationKey(petId: MaybeRef<number>, api_key: MaybeRef<string | null | undefined>): MutationKey {
  return trimArrayEnd([
      'Client',
      'deletePet',
      petId as any,
      api_key as any,
    ]);
}

/**
 * Deletes a pet
 * @param api_key (optional) 
 * @param petId Pet id to delete
 */
export function useDeletePetMutation<TContext>(petId: MaybeRef<number>, api_key: MaybeRef<string | null | undefined>, options?: Omit<UseMutationOptions<void, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationReturnType<void, unknown, void, TContext> {
  const key = deletePetMutationKey(petId, api_key);
  
  return useMutation(() => Client.deletePet(api_key as any, petId as any), {...options, mutationKey: key});
}
  
type DeletePet__MutationParameters = DeletePetQueryParameters

/**
 * Deletes a pet
 * @param api_key (optional) 
 * @param petId Pet id to delete
 */
export function useDeletePetMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, NoRefObject<DeletePet__MutationParameters>, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: DeletePetQueryParameters}): UseMutationReturnType<void, unknown, NoRefObject<DeletePet__MutationParameters>, TContext> {
  const key = deletePetMutationKey(options?.parameters?.petId! as any, options?.parameters?.api_key! as any);
  
return useMutation((data: NoRefObject<DeletePet__MutationParameters>) => Client.deletePet(data.api_key ?? options?.parameters?.api_key! as any, data.petId ?? options?.parameters?.petId! as any), {...options, mutationKey: key});
}
  
export function placeOrderUrl(): string {
  let url_ = getBaseUrl() + "/store/order";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function placeOrderMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'placeOrder',
    ]);
}

/**
 * Place an order for a pet
 * @param body order placed for purchasing the pet
 * @return successful operation
 */
export function usePlaceOrderMutation<TContext>(options?: Omit<UseMutationOptions<Types.Order, unknown, Types.Order, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationReturnType<Types.Order, unknown, Types.Order, TContext> {
  const key = placeOrderMutationKey();
  
  return useMutation((body: Types.Order) => Client.placeOrder(body as any), {...options, mutationKey: key});
}
  
export function getOrderByIdUrl(orderId: number): string {
  let url_ = getBaseUrl() + "/store/order/{orderId}";
if (orderId === undefined || orderId === null)
  throw new Error("The parameter 'orderId' must be defined.");
url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getOrderByIdDefaultOptions: UseQueryOptions<Types.Order, unknown, Types.Order> = {
  queryFn: __getOrderById,
};
export function getGetOrderByIdDefaultOptions(): UseQueryOptions<Types.Order, unknown, Types.Order> {
  return getOrderByIdDefaultOptions;
};
export function setGetOrderByIdDefaultOptions(options: UseQueryOptions<Types.Order, unknown, Types.Order>) {
  getOrderByIdDefaultOptions = options;
}

export function getOrderByIdQueryKey(orderId: number): QueryKey;
export function getOrderByIdQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { orderId,  } = params[0] as GetOrderByIdQueryParameters;

    return trimArrayEnd([
        'Client',
        'getOrderById',
        orderId as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'getOrderById',
        ...params
      ]);
  }
}
function __getOrderById(context: QueryFunctionContext) {
  return Client.getOrderById(
      context.queryKey[2] as number    );
}

export function useGetOrderByIdQuery<TSelectData = Types.Order, TError = unknown>(dto: GetOrderByIdQueryParameters, options?: UseQueryOptions<Types.Order, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryReturnType<TSelectData, TError>;
/**
 * Find purchase order by ID
 * @param orderId ID of pet that needs to be fetched
 * @return successful operation
 */
export function useGetOrderByIdQuery<TSelectData = Types.Order, TError = unknown>(orderId: MaybeRef<number>, options?: UseQueryOptions<Types.Order, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryReturnType<TSelectData, TError>;
export function useGetOrderByIdQuery<TSelectData = Types.Order, TError = unknown>(...params: any []): UseQueryReturnType<TSelectData, TError> {
  let options: UseQueryOptions<Types.Order, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let orderId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ orderId,  } = params[0] as GetOrderByIdQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [orderId, options, axiosConfig] = params;
    }
  }
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.Order, TError, TSelectData>({
    queryFn: __getOrderById,
    queryKey: getOrderByIdQueryKey(orderId),
    ...getOrderByIdDefaultOptions as unknown as UseQueryOptions<Types.Order, TError, TSelectData>,
    ...options,
  });
}
/**
 * Find purchase order by ID
 * @param orderId ID of pet that needs to be fetched
 * @return successful operation
 */
export function setGetOrderByIdData(queryClient: QueryClient, updater: (data: Types.Order | undefined) => Types.Order, orderId: number) {
  queryClient.setQueryData(getOrderByIdQueryKey(orderId),
    updater
  );
}

/**
 * Find purchase order by ID
 * @param orderId ID of pet that needs to be fetched
 * @return successful operation
 */
export function setGetOrderByIdDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.Order | undefined) => Types.Order) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function deleteOrderUrl(orderId: number): string {
  let url_ = getBaseUrl() + "/store/order/{orderId}";
if (orderId === undefined || orderId === null)
  throw new Error("The parameter 'orderId' must be defined.");
url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function deleteOrderMutationKey(orderId: MaybeRef<number>): MutationKey {
  return trimArrayEnd([
      'Client',
      'deleteOrder',
      orderId as any,
    ]);
}

/**
 * Delete purchase order by ID
 * @param orderId ID of the order that needs to be deleted
 */
export function useDeleteOrderMutation<TContext>(orderId: MaybeRef<number>, options?: Omit<UseMutationOptions<void, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationReturnType<void, unknown, void, TContext> {
  const key = deleteOrderMutationKey(orderId);
  
  return useMutation(() => Client.deleteOrder(orderId as any), {...options, mutationKey: key});
}
  
type DeleteOrder__MutationParameters = DeleteOrderQueryParameters

/**
 * Delete purchase order by ID
 * @param orderId ID of the order that needs to be deleted
 */
export function useDeleteOrderMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, NoRefObject<DeleteOrder__MutationParameters>, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: DeleteOrderQueryParameters}): UseMutationReturnType<void, unknown, NoRefObject<DeleteOrder__MutationParameters>, TContext> {
  const key = deleteOrderMutationKey(options?.parameters?.orderId! as any);
  
return useMutation((data: NoRefObject<DeleteOrder__MutationParameters>) => Client.deleteOrder(data.orderId ?? options?.parameters?.orderId! as any), {...options, mutationKey: key});
}
  
export function getInventoryUrl(): string {
  let url_ = getBaseUrl() + "/store/inventory";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getInventoryDefaultOptions: UseQueryOptions<{ [key: string]: number; }, unknown, { [key: string]: number; }> = {
  queryFn: __getInventory,
};
export function getGetInventoryDefaultOptions(): UseQueryOptions<{ [key: string]: number; }, unknown, { [key: string]: number; }> {
  return getInventoryDefaultOptions;
};
export function setGetInventoryDefaultOptions(options: UseQueryOptions<{ [key: string]: number; }, unknown, { [key: string]: number; }>) {
  getInventoryDefaultOptions = options;
}

export function getInventoryQueryKey(): QueryKey;
export function getInventoryQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'getInventory',
    ]);
}
function __getInventory() {
  return Client.getInventory(
    );
}

/**
 * Returns pet inventories by status
 * @return successful operation
 */
export function useGetInventoryQuery<TSelectData = { [key: string]: number; }, TError = unknown>(options?: UseQueryOptions<{ [key: string]: number; }, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryReturnType<TSelectData, TError>;
export function useGetInventoryQuery<TSelectData = { [key: string]: number; }, TError = unknown>(...params: any []): UseQueryReturnType<TSelectData, TError> {
  let options: UseQueryOptions<{ [key: string]: number; }, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<{ [key: string]: number; }, TError, TSelectData>({
    queryFn: __getInventory,
    queryKey: getInventoryQueryKey(),
    ...getInventoryDefaultOptions as unknown as UseQueryOptions<{ [key: string]: number; }, TError, TSelectData>,
    ...options,
  });
}
/**
 * Returns pet inventories by status
 * @return successful operation
 */
export function setGetInventoryData(queryClient: QueryClient, updater: (data: { [key: string]: number; } | undefined) => { [key: string]: number; }, ) {
  queryClient.setQueryData(getInventoryQueryKey(),
    updater
  );
}

/**
 * Returns pet inventories by status
 * @return successful operation
 */
export function setGetInventoryDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: { [key: string]: number; } | undefined) => { [key: string]: number; }) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function createUsersWithArrayInputUrl(): string {
  let url_ = getBaseUrl() + "/user/createWithArray";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function createUsersWithArrayInputMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'createUsersWithArrayInput',
    ]);
}

/**
 * Creates list of users with given input array
 * @param body List of user object
 * @return successful operation
 */
export function useCreateUsersWithArrayInputMutation<TContext>(options?: Omit<UseMutationOptions<void, unknown, Types.User[], TContext>, 'mutationKey' | 'mutationFn'>): UseMutationReturnType<void, unknown, Types.User[], TContext> {
  const key = createUsersWithArrayInputMutationKey();
  
  return useMutation((body: Types.User[]) => Client.createUsersWithArrayInput(body as any), {...options, mutationKey: key});
}
  
export function createUsersWithListInputUrl(): string {
  let url_ = getBaseUrl() + "/user/createWithList";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function createUsersWithListInputMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'createUsersWithListInput',
    ]);
}

/**
 * Creates list of users with given input array
 * @param body List of user object
 * @return successful operation
 */
export function useCreateUsersWithListInputMutation<TContext>(options?: Omit<UseMutationOptions<void, unknown, Types.User[], TContext>, 'mutationKey' | 'mutationFn'>): UseMutationReturnType<void, unknown, Types.User[], TContext> {
  const key = createUsersWithListInputMutationKey();
  
  return useMutation((body: Types.User[]) => Client.createUsersWithListInput(body as any), {...options, mutationKey: key});
}
  
export function getUserByNameUrl(username: string): string {
  let url_ = getBaseUrl() + "/user/{username}";
if (username === undefined || username === null)
  throw new Error("The parameter 'username' must be defined.");
url_ = url_.replace("{username}", encodeURIComponent("" + username));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getUserByNameDefaultOptions: UseQueryOptions<Types.User, unknown, Types.User> = {
  queryFn: __getUserByName,
};
export function getGetUserByNameDefaultOptions(): UseQueryOptions<Types.User, unknown, Types.User> {
  return getUserByNameDefaultOptions;
};
export function setGetUserByNameDefaultOptions(options: UseQueryOptions<Types.User, unknown, Types.User>) {
  getUserByNameDefaultOptions = options;
}

export function getUserByNameQueryKey(username: string): QueryKey;
export function getUserByNameQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { username,  } = params[0] as GetUserByNameQueryParameters;

    return trimArrayEnd([
        'Client',
        'getUserByName',
        username as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'getUserByName',
        ...params
      ]);
  }
}
function __getUserByName(context: QueryFunctionContext) {
  return Client.getUserByName(
      context.queryKey[2] as string    );
}

export function useGetUserByNameQuery<TSelectData = Types.User, TError = unknown>(dto: GetUserByNameQueryParameters, options?: UseQueryOptions<Types.User, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryReturnType<TSelectData, TError>;
/**
 * Get user by user name
 * @param username The name that needs to be fetched. Use user1 for testing.
 * @return successful operation
 */
export function useGetUserByNameQuery<TSelectData = Types.User, TError = unknown>(username: MaybeRef<string>, options?: UseQueryOptions<Types.User, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryReturnType<TSelectData, TError>;
export function useGetUserByNameQuery<TSelectData = Types.User, TError = unknown>(...params: any []): UseQueryReturnType<TSelectData, TError> {
  let options: UseQueryOptions<Types.User, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let username: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ username,  } = params[0] as GetUserByNameQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [username, options, axiosConfig] = params;
    }
  }
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<Types.User, TError, TSelectData>({
    queryFn: __getUserByName,
    queryKey: getUserByNameQueryKey(username),
    ...getUserByNameDefaultOptions as unknown as UseQueryOptions<Types.User, TError, TSelectData>,
    ...options,
  });
}
/**
 * Get user by user name
 * @param username The name that needs to be fetched. Use user1 for testing.
 * @return successful operation
 */
export function setGetUserByNameData(queryClient: QueryClient, updater: (data: Types.User | undefined) => Types.User, username: string) {
  queryClient.setQueryData(getUserByNameQueryKey(username),
    updater
  );
}

/**
 * Get user by user name
 * @param username The name that needs to be fetched. Use user1 for testing.
 * @return successful operation
 */
export function setGetUserByNameDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.User | undefined) => Types.User) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function updateUserUrl(username: string): string {
  let url_ = getBaseUrl() + "/user/{username}";
if (username === undefined || username === null)
  throw new Error("The parameter 'username' must be defined.");
url_ = url_.replace("{username}", encodeURIComponent("" + username));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function updateUserMutationKey(username: MaybeRef<string>): MutationKey {
  return trimArrayEnd([
      'Client',
      'updateUser',
      username as any,
    ]);
}

/**
 * Updated user
 * @param username name that need to be updated
 * @param body Updated user object
 */
export function useUpdateUserMutation<TContext>(username: MaybeRef<string>, options?: Omit<UseMutationOptions<void, unknown, Types.User, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationReturnType<void, unknown, Types.User, TContext> {
  const key = updateUserMutationKey(username);
  
  return useMutation((body: Types.User) => Client.updateUser(username as any, body as any), {...options, mutationKey: key});
}
  
type UpdateUser__MutationParameters = UpdateUserQueryParameters & {
  body: Types.User;
}

/**
 * Updated user
 * @param username name that need to be updated
 * @param body Updated user object
 */
export function useUpdateUserMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, NoRefObject<UpdateUser__MutationParameters>, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: UpdateUserQueryParameters}): UseMutationReturnType<void, unknown, NoRefObject<UpdateUser__MutationParameters>, TContext> {
  const key = updateUserMutationKey(options?.parameters?.username! as any);
  
return useMutation((data: NoRefObject<UpdateUser__MutationParameters>) => Client.updateUser(data.username ?? options?.parameters?.username! as any, data.body), {...options, mutationKey: key});
}
  
export function deleteUserUrl(username: string): string {
  let url_ = getBaseUrl() + "/user/{username}";
if (username === undefined || username === null)
  throw new Error("The parameter 'username' must be defined.");
url_ = url_.replace("{username}", encodeURIComponent("" + username));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function deleteUserMutationKey(username: MaybeRef<string>): MutationKey {
  return trimArrayEnd([
      'Client',
      'deleteUser',
      username as any,
    ]);
}

/**
 * Delete user
 * @param username The name that needs to be deleted
 */
export function useDeleteUserMutation<TContext>(username: MaybeRef<string>, options?: Omit<UseMutationOptions<void, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationReturnType<void, unknown, void, TContext> {
  const key = deleteUserMutationKey(username);
  
  return useMutation(() => Client.deleteUser(username as any), {...options, mutationKey: key});
}
  
type DeleteUser__MutationParameters = DeleteUserQueryParameters

/**
 * Delete user
 * @param username The name that needs to be deleted
 */
export function useDeleteUserMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, NoRefObject<DeleteUser__MutationParameters>, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: DeleteUserQueryParameters}): UseMutationReturnType<void, unknown, NoRefObject<DeleteUser__MutationParameters>, TContext> {
  const key = deleteUserMutationKey(options?.parameters?.username! as any);
  
return useMutation((data: NoRefObject<DeleteUser__MutationParameters>) => Client.deleteUser(data.username ?? options?.parameters?.username! as any), {...options, mutationKey: key});
}
  
export function loginUserUrl(username: string, password: string): string {
  let url_ = getBaseUrl() + "/user/login?";
  if (username === undefined || username === null)
    throw new Error("The parameter 'username' must be defined and cannot be null.");
  else
    url_ += "username=" + encodeURIComponent("" + username) + "&";
  if (password === undefined || password === null)
    throw new Error("The parameter 'password' must be defined and cannot be null.");
  else
    url_ += "password=" + encodeURIComponent("" + password) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let loginUserDefaultOptions: UseQueryOptions<string, unknown, string> = {
  queryFn: __loginUser,
};
export function getLoginUserDefaultOptions(): UseQueryOptions<string, unknown, string> {
  return loginUserDefaultOptions;
};
export function setLoginUserDefaultOptions(options: UseQueryOptions<string, unknown, string>) {
  loginUserDefaultOptions = options;
}

export function loginUserQueryKey(dto: LoginUserQueryParameters): QueryKey;
export function loginUserQueryKey(username: string, password: string): QueryKey;
export function loginUserQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { username, password,  } = params[0] as LoginUserQueryParameters;

    return trimArrayEnd([
        'Client',
        'loginUser',
        username as any,
        password as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'loginUser',
        ...params
      ]);
  }
}
function __loginUser(context: QueryFunctionContext) {
  return Client.loginUser(
      context.queryKey[2] as string,       context.queryKey[3] as string    );
}

export function useLoginUserQuery<TSelectData = string, TError = unknown>(dto: LoginUserQueryParameters, options?: UseQueryOptions<string, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryReturnType<TSelectData, TError>;
/**
 * Logs user into the system
 * @param username The user name for login
 * @param password The password for login in clear text
 * @return successful operation
 */
export function useLoginUserQuery<TSelectData = string, TError = unknown>(username: MaybeRef<string>, password: MaybeRef<string>, options?: UseQueryOptions<string, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryReturnType<TSelectData, TError>;
export function useLoginUserQuery<TSelectData = string, TError = unknown>(...params: any []): UseQueryReturnType<TSelectData, TError> {
  let options: UseQueryOptions<string, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  let username: any = undefined;
  let password: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ username, password,  } = params[0] as LoginUserQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [username, password, options, axiosConfig] = params;
    }
  }
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<string, TError, TSelectData>({
    queryFn: __loginUser,
    queryKey: loginUserQueryKey(username, password),
    ...loginUserDefaultOptions as unknown as UseQueryOptions<string, TError, TSelectData>,
    ...options,
  });
}
/**
 * Logs user into the system
 * @param username The user name for login
 * @param password The password for login in clear text
 * @return successful operation
 */
export function setLoginUserData(queryClient: QueryClient, updater: (data: string | undefined) => string, username: string, password: string) {
  queryClient.setQueryData(loginUserQueryKey(username, password),
    updater
  );
}

/**
 * Logs user into the system
 * @param username The user name for login
 * @param password The password for login in clear text
 * @return successful operation
 */
export function setLoginUserDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: string | undefined) => string) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function logoutUserUrl(): string {
  let url_ = getBaseUrl() + "/user/logout";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let logoutUserDefaultOptions: UseQueryOptions<void, unknown, void> = {
  queryFn: __logoutUser,
};
export function getLogoutUserDefaultOptions(): UseQueryOptions<void, unknown, void> {
  return logoutUserDefaultOptions;
};
export function setLogoutUserDefaultOptions(options: UseQueryOptions<void, unknown, void>) {
  logoutUserDefaultOptions = options;
}

export function logoutUserQueryKey(): QueryKey;
export function logoutUserQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'logoutUser',
    ]);
}
function __logoutUser() {
  return Client.logoutUser(
    );
}

/**
 * Logs out current logged in user session
 * @return successful operation
 */
export function useLogoutUserQuery<TSelectData = void, TError = unknown>(options?: UseQueryOptions<void, TError, TSelectData>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryReturnType<TSelectData, TError>;
export function useLogoutUserQuery<TSelectData = void, TError = unknown>(...params: any []): UseQueryReturnType<TSelectData, TError> {
  let options: UseQueryOptions<void, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;
  if (axiosConfig) {
    options = options ?? { } as any;
    options!.meta = { ...options!.meta, axiosConfig };
  }

  return useQuery<void, TError, TSelectData>({
    queryFn: __logoutUser,
    queryKey: logoutUserQueryKey(),
    ...logoutUserDefaultOptions as unknown as UseQueryOptions<void, TError, TSelectData>,
    ...options,
  });
}
/**
 * Logs out current logged in user session
 * @return successful operation
 */
export function setLogoutUserData(queryClient: QueryClient, updater: (data: void | undefined) => void, ) {
  queryClient.setQueryData(logoutUserQueryKey(),
    updater
  );
}

/**
 * Logs out current logged in user session
 * @return successful operation
 */
export function setLogoutUserDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: void | undefined) => void) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function createUserUrl(): string {
  let url_ = getBaseUrl() + "/user";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function createUserMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'createUser',
    ]);
}

/**
 * Create user
 * @param body Created user object
 * @return successful operation
 */
export function useCreateUserMutation<TContext>(options?: Omit<UseMutationOptions<void, unknown, Types.User, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationReturnType<void, unknown, Types.User, TContext> {
  const key = createUserMutationKey();
  
  return useMutation((body: Types.User) => Client.createUser(body as any), {...options, mutationKey: key});
}
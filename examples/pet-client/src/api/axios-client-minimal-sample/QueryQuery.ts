//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming
import * as Types from '../axios-client-minimal-sample.types';
import { useQuery, useMutation } from '@tanstack/react-query';
import type { UseQueryResult, QueryFunctionContext, UseQueryOptions, QueryClient, QueryKey, MutationKey, UseMutationOptions, UseMutationResult, QueryMeta, MutationMeta } from '@tanstack/react-query';
import { trimArrayEnd, isParameterObject, getBaseUrl, addMetaToOptions } from './helpers';
import type { QueryMetaContextValue } from 'react-query-swagger';
import { QueryMetaContext } from 'react-query-swagger';
import { useContext } from 'react';
import * as Client from './QueryClient'
export { Client };
import type { AxiosRequestConfig } from 'axios';

export type JsonInQueryQueryQueryParameters = {
  dto?: Types.DummyDto | null | undefined ;
}

export type JsonInNestedQueryQueryQueryParameters = {
  test?: string | undefined ;
  dummy?: Types.DummyDto | undefined ;
}

export type DateOnlyInQueryQueryQueryParameters = {
  date?: Date | undefined ;
}

export type DateTimeInQueryQueryQueryParameters = {
  date?: Date | undefined ;
}

export type ArrayInQueryQueryQueryParameters = {
  data?: string[] | null | undefined ;
}

export type DictionaryInQueryQueryQueryParameters = {
  data?: { [key: string]: string; } | null | undefined ;
}

export type DictionaryInJsonQueryQueryQueryParameters = {
  data?: { [key: string]: string; } | null | undefined ;
}

export type GetViaPostQueryQueryParameters = {
  dto: Types.DummyDto ;
}

export type WithBodyQueryQueryParameters = {
  dto: Types.BodyDto ;
}

export type WithClassInQueryQueryQueryParameters = {
  tst?: string | undefined ;
}

export function jsonInQueryUrl(dto?: Types.DummyDto | null | undefined): string {
  let url_ = getBaseUrl() + "/query/JsonInQuery?";
if (dto !== undefined && dto !== null)
{
    const content_ = Types.serializeDummyDto(dto);
    url_ += "dto=" + encodeURIComponent(content_) + "&";
}
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let jsonInQueryDefaultOptions: Omit<UseQueryOptions<string, unknown, string>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<string, unknown, string>, 'queryFn'>> = {
};
export function getJsonInQueryDefaultOptions() {
  return jsonInQueryDefaultOptions;
};
export function setJsonInQueryDefaultOptions(options: typeof jsonInQueryDefaultOptions) {
  jsonInQueryDefaultOptions = options;
}

export function jsonInQueryQueryKey(dto?: Types.DummyDto | null | undefined): QueryKey;
export function jsonInQueryQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { dto,  } = params[0] as JsonInQueryQueryQueryParameters;

    return trimArrayEnd([
        'QueryClient',
        'jsonInQuery',
        dto as any,
      ]);
  } else {
    return trimArrayEnd([
        'QueryClient',
        'jsonInQuery',
        ...params
      ]);
  }
}
export function __jsonInQuery(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.jsonInQuery(
      context.queryKey[2] as Types.DummyDto | null | undefined,axiosConfig    );
}

export function useJsonInQueryQuery<TSelectData = string, TError = unknown>(dto: JsonInQueryQueryQueryParameters, options?: Omit<UseQueryOptions<string, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;

export function useJsonInQueryQuery<TSelectData = string, TError = unknown>(dto?: Types.DummyDto | null | undefined, options?: Omit<UseQueryOptions<string, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useJsonInQueryQuery<TSelectData = string, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<string, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let dto: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ dto,  } = params[0] as JsonInQueryQueryQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [dto, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<string, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __jsonInQuery(context, axiosConfig) : __jsonInQuery,
    queryKey: jsonInQueryQueryKey(dto),
    ...jsonInQueryDefaultOptions as unknown as Omit<UseQueryOptions<string, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}

export function setJsonInQueryData(queryClient: QueryClient, updater: (data: string | undefined) => string, dto?: Types.DummyDto | null | undefined) {
  queryClient.setQueryData(jsonInQueryQueryKey(dto),
    updater
  );
}

export function setJsonInQueryDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: string | undefined) => string) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function jsonInNestedQueryUrl(test?: string | undefined, dummy?: Types.DummyDto | undefined): string {
  let url_ = getBaseUrl() + "/query/JsonInNested?";
if (test === null)
    throw new Error("The parameter 'test' cannot be null.");
else if (test !== undefined)
    url_ += "Test=" + encodeURIComponent("" + test) + "&";
if (dummy === null)
    throw new Error("The parameter 'dummy' cannot be null.");
else if (dummy !== undefined)
{
    const content_ = Types.serializeDummyDto(dummy);
    url_ += "Dummy=" + encodeURIComponent(content_) + "&";
}
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let jsonInNestedQueryDefaultOptions: Omit<UseQueryOptions<string, unknown, string>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<string, unknown, string>, 'queryFn'>> = {
};
export function getJsonInNestedQueryDefaultOptions() {
  return jsonInNestedQueryDefaultOptions;
};
export function setJsonInNestedQueryDefaultOptions(options: typeof jsonInNestedQueryDefaultOptions) {
  jsonInNestedQueryDefaultOptions = options;
}

export function jsonInNestedQueryQueryKey(dto: JsonInNestedQueryQueryQueryParameters): QueryKey;
export function jsonInNestedQueryQueryKey(test?: string | undefined, dummy?: Types.DummyDto | undefined): QueryKey;
export function jsonInNestedQueryQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { test, dummy,  } = params[0] as JsonInNestedQueryQueryQueryParameters;

    return trimArrayEnd([
        'QueryClient',
        'jsonInNestedQuery',
        test as any,
        dummy as any,
      ]);
  } else {
    return trimArrayEnd([
        'QueryClient',
        'jsonInNestedQuery',
        ...params
      ]);
  }
}
export function __jsonInNestedQuery(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.jsonInNestedQuery(
      context.queryKey[2] as string | undefined,       context.queryKey[3] as Types.DummyDto | undefined,axiosConfig    );
}

export function useJsonInNestedQueryQuery<TSelectData = string, TError = unknown>(dto: JsonInNestedQueryQueryQueryParameters, options?: Omit<UseQueryOptions<string, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;

export function useJsonInNestedQueryQuery<TSelectData = string, TError = unknown>(test?: string | undefined, dummy?: Types.DummyDto | undefined, options?: Omit<UseQueryOptions<string, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useJsonInNestedQueryQuery<TSelectData = string, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<string, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let test: any = undefined;
  let dummy: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ test, dummy,  } = params[0] as JsonInNestedQueryQueryQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [test, dummy, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<string, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __jsonInNestedQuery(context, axiosConfig) : __jsonInNestedQuery,
    queryKey: jsonInNestedQueryQueryKey(test, dummy),
    ...jsonInNestedQueryDefaultOptions as unknown as Omit<UseQueryOptions<string, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}

export function setJsonInNestedQueryData(queryClient: QueryClient, updater: (data: string | undefined) => string, test?: string | undefined, dummy?: Types.DummyDto | undefined) {
  queryClient.setQueryData(jsonInNestedQueryQueryKey(test, dummy),
    updater
  );
}

export function setJsonInNestedQueryDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: string | undefined) => string) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function dateOnlyInQueryUrl(date?: Date | undefined): string {
  let url_ = getBaseUrl() + "/query/DateOnlyInQuery?";
if (date === null)
    throw new Error("The parameter 'date' cannot be null.");
else if (date !== undefined)
    url_ += "date=" + encodeURIComponent(date ? "" + Types.formatDate(date) : "") + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let dateOnlyInQueryDefaultOptions: Omit<UseQueryOptions<string, unknown, string>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<string, unknown, string>, 'queryFn'>> = {
};
export function getDateOnlyInQueryDefaultOptions() {
  return dateOnlyInQueryDefaultOptions;
};
export function setDateOnlyInQueryDefaultOptions(options: typeof dateOnlyInQueryDefaultOptions) {
  dateOnlyInQueryDefaultOptions = options;
}

export function dateOnlyInQueryQueryKey(date?: Date | undefined): QueryKey;
export function dateOnlyInQueryQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { date,  } = params[0] as DateOnlyInQueryQueryQueryParameters;

    return trimArrayEnd([
        'QueryClient',
        'dateOnlyInQuery',
        date as any,
      ]);
  } else {
    return trimArrayEnd([
        'QueryClient',
        'dateOnlyInQuery',
        ...params
      ]);
  }
}
export function __dateOnlyInQuery(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.dateOnlyInQuery(
      context.queryKey[2] as Date | undefined,axiosConfig    );
}

export function useDateOnlyInQueryQuery<TSelectData = string, TError = unknown>(dto: DateOnlyInQueryQueryQueryParameters, options?: Omit<UseQueryOptions<string, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;

export function useDateOnlyInQueryQuery<TSelectData = string, TError = unknown>(date?: Date | undefined, options?: Omit<UseQueryOptions<string, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useDateOnlyInQueryQuery<TSelectData = string, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<string, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let date: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ date,  } = params[0] as DateOnlyInQueryQueryQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [date, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<string, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __dateOnlyInQuery(context, axiosConfig) : __dateOnlyInQuery,
    queryKey: dateOnlyInQueryQueryKey(date),
    ...dateOnlyInQueryDefaultOptions as unknown as Omit<UseQueryOptions<string, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}

export function setDateOnlyInQueryData(queryClient: QueryClient, updater: (data: string | undefined) => string, date?: Date | undefined) {
  queryClient.setQueryData(dateOnlyInQueryQueryKey(date),
    updater
  );
}

export function setDateOnlyInQueryDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: string | undefined) => string) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function dateTimeInQueryUrl(date?: Date | undefined): string {
  let url_ = getBaseUrl() + "/query/DateTimeInQuery?";
if (date === null)
    throw new Error("The parameter 'date' cannot be null.");
else if (date !== undefined)
    url_ += "date=" + encodeURIComponent(date ? "" + date.toISOString() : "") + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let dateTimeInQueryDefaultOptions: Omit<UseQueryOptions<string, unknown, string>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<string, unknown, string>, 'queryFn'>> = {
};
export function getDateTimeInQueryDefaultOptions() {
  return dateTimeInQueryDefaultOptions;
};
export function setDateTimeInQueryDefaultOptions(options: typeof dateTimeInQueryDefaultOptions) {
  dateTimeInQueryDefaultOptions = options;
}

export function dateTimeInQueryQueryKey(date?: Date | undefined): QueryKey;
export function dateTimeInQueryQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { date,  } = params[0] as DateTimeInQueryQueryQueryParameters;

    return trimArrayEnd([
        'QueryClient',
        'dateTimeInQuery',
        date as any,
      ]);
  } else {
    return trimArrayEnd([
        'QueryClient',
        'dateTimeInQuery',
        ...params
      ]);
  }
}
export function __dateTimeInQuery(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.dateTimeInQuery(
      context.queryKey[2] as Date | undefined,axiosConfig    );
}

export function useDateTimeInQueryQuery<TSelectData = string, TError = unknown>(dto: DateTimeInQueryQueryQueryParameters, options?: Omit<UseQueryOptions<string, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;

export function useDateTimeInQueryQuery<TSelectData = string, TError = unknown>(date?: Date | undefined, options?: Omit<UseQueryOptions<string, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useDateTimeInQueryQuery<TSelectData = string, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<string, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let date: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ date,  } = params[0] as DateTimeInQueryQueryQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [date, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<string, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __dateTimeInQuery(context, axiosConfig) : __dateTimeInQuery,
    queryKey: dateTimeInQueryQueryKey(date),
    ...dateTimeInQueryDefaultOptions as unknown as Omit<UseQueryOptions<string, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}

export function setDateTimeInQueryData(queryClient: QueryClient, updater: (data: string | undefined) => string, date?: Date | undefined) {
  queryClient.setQueryData(dateTimeInQueryQueryKey(date),
    updater
  );
}

export function setDateTimeInQueryDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: string | undefined) => string) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function arrayInQueryUrl(data?: string[] | null | undefined): string {
  let url_ = getBaseUrl() + "/query/ArrayInQuery?";
if (data !== undefined && data !== null)
    data && data.forEach(item => { url_ += "data=" + encodeURIComponent("" + item) + "&"; });
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let arrayInQueryDefaultOptions: Omit<UseQueryOptions<string[], unknown, string[]>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<string[], unknown, string[]>, 'queryFn'>> = {
};
export function getArrayInQueryDefaultOptions() {
  return arrayInQueryDefaultOptions;
};
export function setArrayInQueryDefaultOptions(options: typeof arrayInQueryDefaultOptions) {
  arrayInQueryDefaultOptions = options;
}

export function arrayInQueryQueryKey(data?: string[] | null | undefined): QueryKey;
export function arrayInQueryQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { data,  } = params[0] as ArrayInQueryQueryQueryParameters;

    return trimArrayEnd([
        'QueryClient',
        'arrayInQuery',
        data as any,
      ]);
  } else {
    return trimArrayEnd([
        'QueryClient',
        'arrayInQuery',
        ...params
      ]);
  }
}
export function __arrayInQuery(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.arrayInQuery(
      context.queryKey[2] as string[] | null | undefined,axiosConfig    );
}

export function useArrayInQueryQuery<TSelectData = string[], TError = unknown>(dto: ArrayInQueryQueryQueryParameters, options?: Omit<UseQueryOptions<string[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;

export function useArrayInQueryQuery<TSelectData = string[], TError = unknown>(data?: string[] | null | undefined, options?: Omit<UseQueryOptions<string[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useArrayInQueryQuery<TSelectData = string[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<string[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let data: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ data,  } = params[0] as ArrayInQueryQueryQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [data, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<string[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __arrayInQuery(context, axiosConfig) : __arrayInQuery,
    queryKey: arrayInQueryQueryKey(data),
    ...arrayInQueryDefaultOptions as unknown as Omit<UseQueryOptions<string[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}

export function setArrayInQueryData(queryClient: QueryClient, updater: (data: string[] | undefined) => string[], data?: string[] | null | undefined) {
  queryClient.setQueryData(arrayInQueryQueryKey(data),
    updater
  );
}

export function setArrayInQueryDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: string[] | undefined) => string[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function dictionaryInQueryUrl(data?: { [key: string]: string; } | null | undefined): string {
  let url_ = getBaseUrl() + "/query/DictionaryInQuery?";
if (data !== undefined && data !== null)
    data && Object.keys(data).forEach(key => { url_ += encodeURIComponent(key) +"=" + encodeURIComponent("" + data[key]) + "&"; });
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let dictionaryInQueryDefaultOptions: Omit<UseQueryOptions<{ [key: string]: string; }, unknown, { [key: string]: string; }>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<{ [key: string]: string; }, unknown, { [key: string]: string; }>, 'queryFn'>> = {
};
export function getDictionaryInQueryDefaultOptions() {
  return dictionaryInQueryDefaultOptions;
};
export function setDictionaryInQueryDefaultOptions(options: typeof dictionaryInQueryDefaultOptions) {
  dictionaryInQueryDefaultOptions = options;
}

export function dictionaryInQueryQueryKey(data?: { [key: string]: string; } | null | undefined): QueryKey;
export function dictionaryInQueryQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { data,  } = params[0] as DictionaryInQueryQueryQueryParameters;

    return trimArrayEnd([
        'QueryClient',
        'dictionaryInQuery',
        data as any,
      ]);
  } else {
    return trimArrayEnd([
        'QueryClient',
        'dictionaryInQuery',
        ...params
      ]);
  }
}
export function __dictionaryInQuery(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.dictionaryInQuery(
      context.queryKey[2] as { [key: string]: string; } | null | undefined,axiosConfig    );
}

export function useDictionaryInQueryQuery<TSelectData = { [key: string]: string; }, TError = unknown>(dto: DictionaryInQueryQueryQueryParameters, options?: Omit<UseQueryOptions<{ [key: string]: string; }, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;

export function useDictionaryInQueryQuery<TSelectData = { [key: string]: string; }, TError = unknown>(data?: { [key: string]: string; } | null | undefined, options?: Omit<UseQueryOptions<{ [key: string]: string; }, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useDictionaryInQueryQuery<TSelectData = { [key: string]: string; }, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<{ [key: string]: string; }, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let data: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ data,  } = params[0] as DictionaryInQueryQueryQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [data, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<{ [key: string]: string; }, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __dictionaryInQuery(context, axiosConfig) : __dictionaryInQuery,
    queryKey: dictionaryInQueryQueryKey(data),
    ...dictionaryInQueryDefaultOptions as unknown as Omit<UseQueryOptions<{ [key: string]: string; }, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}

export function setDictionaryInQueryData(queryClient: QueryClient, updater: (data: { [key: string]: string; } | undefined) => { [key: string]: string; }, data?: { [key: string]: string; } | null | undefined) {
  queryClient.setQueryData(dictionaryInQueryQueryKey(data),
    updater
  );
}

export function setDictionaryInQueryDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: { [key: string]: string; } | undefined) => { [key: string]: string; }) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function dictionaryInJsonQueryUrl(data?: { [key: string]: string; } | null | undefined): string {
  let url_ = getBaseUrl() + "/query/DictionaryInJsonQuery?";
if (data !== undefined && data !== null)
{
    const content_ = JSON.stringify(data);
    url_ += "data=" + encodeURIComponent(content_) + "&";
}
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let dictionaryInJsonQueryDefaultOptions: Omit<UseQueryOptions<{ [key: string]: string; }, unknown, { [key: string]: string; }>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<{ [key: string]: string; }, unknown, { [key: string]: string; }>, 'queryFn'>> = {
};
export function getDictionaryInJsonQueryDefaultOptions() {
  return dictionaryInJsonQueryDefaultOptions;
};
export function setDictionaryInJsonQueryDefaultOptions(options: typeof dictionaryInJsonQueryDefaultOptions) {
  dictionaryInJsonQueryDefaultOptions = options;
}

export function dictionaryInJsonQueryQueryKey(data?: { [key: string]: string; } | null | undefined): QueryKey;
export function dictionaryInJsonQueryQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { data,  } = params[0] as DictionaryInJsonQueryQueryQueryParameters;

    return trimArrayEnd([
        'QueryClient',
        'dictionaryInJsonQuery',
        data as any,
      ]);
  } else {
    return trimArrayEnd([
        'QueryClient',
        'dictionaryInJsonQuery',
        ...params
      ]);
  }
}
export function __dictionaryInJsonQuery(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.dictionaryInJsonQuery(
      context.queryKey[2] as { [key: string]: string; } | null | undefined,axiosConfig    );
}

export function useDictionaryInJsonQueryQuery<TSelectData = { [key: string]: string; }, TError = unknown>(dto: DictionaryInJsonQueryQueryQueryParameters, options?: Omit<UseQueryOptions<{ [key: string]: string; }, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;

export function useDictionaryInJsonQueryQuery<TSelectData = { [key: string]: string; }, TError = unknown>(data?: { [key: string]: string; } | null | undefined, options?: Omit<UseQueryOptions<{ [key: string]: string; }, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useDictionaryInJsonQueryQuery<TSelectData = { [key: string]: string; }, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<{ [key: string]: string; }, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let data: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ data,  } = params[0] as DictionaryInJsonQueryQueryQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [data, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<{ [key: string]: string; }, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __dictionaryInJsonQuery(context, axiosConfig) : __dictionaryInJsonQuery,
    queryKey: dictionaryInJsonQueryQueryKey(data),
    ...dictionaryInJsonQueryDefaultOptions as unknown as Omit<UseQueryOptions<{ [key: string]: string; }, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}

export function setDictionaryInJsonQueryData(queryClient: QueryClient, updater: (data: { [key: string]: string; } | undefined) => { [key: string]: string; }, data?: { [key: string]: string; } | null | undefined) {
  queryClient.setQueryData(dictionaryInJsonQueryQueryKey(data),
    updater
  );
}

export function setDictionaryInJsonQueryDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: { [key: string]: string; } | undefined) => { [key: string]: string; }) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function getViaPostUrl(): string {
  let url_ = getBaseUrl() + "/query/GetViaPost";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function getViaPostMutationKey(): MutationKey {
  return trimArrayEnd([
      'QueryClient',
      'getViaPost',
    ]);
}

export function useGetViaPostMutation<TContext>(options?: Omit<UseMutationOptions<Types.DummyDto, unknown, Types.DummyDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.DummyDto, unknown, Types.DummyDto, TContext> {
  const key = getViaPostMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (dto: Types.DummyDto) => Client.getViaPost(dto),
    mutationKey: key,
  });
}
let getViaPostDefaultOptions: Omit<UseQueryOptions<Types.DummyDto, unknown, Types.DummyDto>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<Types.DummyDto, unknown, Types.DummyDto>, 'queryFn'>> = {
};
export function getGetViaPostDefaultOptions() {
  return getViaPostDefaultOptions;
};
export function setGetViaPostDefaultOptions(options: typeof getViaPostDefaultOptions) {
  getViaPostDefaultOptions = options;
}

export function getViaPostQueryKey(dto: Types.DummyDto): QueryKey;
export function getViaPostQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { dto,  } = params[0] as GetViaPostQueryQueryParameters;

    return trimArrayEnd([
        'QueryClient',
        'getViaPost',
        dto as any,
      ]);
  } else {
    return trimArrayEnd([
        'QueryClient',
        'getViaPost',
        ...params
      ]);
  }
}
export function __getViaPost(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.getViaPost(
      context.queryKey[2] as Types.DummyDto,axiosConfig    );
}

export function useGetViaPostQuery<TSelectData = Types.DummyDto, TError = unknown>(dto: GetViaPostQueryQueryParameters, options?: Omit<UseQueryOptions<Types.DummyDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;

export function useGetViaPostQuery<TSelectData = Types.DummyDto, TError = unknown>(dto: Types.DummyDto, options?: Omit<UseQueryOptions<Types.DummyDto, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useGetViaPostQuery<TSelectData = Types.DummyDto, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.DummyDto, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let dto: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ dto,  } = params[0] as GetViaPostQueryQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [dto, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.DummyDto, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __getViaPost(context, axiosConfig) : __getViaPost,
    queryKey: getViaPostQueryKey(dto),
    ...getViaPostDefaultOptions as unknown as Omit<UseQueryOptions<Types.DummyDto, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}

export function setGetViaPostData(queryClient: QueryClient, updater: (data: Types.DummyDto | undefined) => Types.DummyDto, dto: Types.DummyDto) {
  queryClient.setQueryData(getViaPostQueryKey(dto),
    updater
  );
}

export function setGetViaPostDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.DummyDto | undefined) => Types.DummyDto) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function nonGetViaPostUrl(): string {
  let url_ = getBaseUrl() + "/query/NonGetViaPost";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function nonGetViaPostMutationKey(): MutationKey {
  return trimArrayEnd([
      'QueryClient',
      'nonGetViaPost',
    ]);
}

export function useNonGetViaPostMutation<TContext>(options?: Omit<UseMutationOptions<Types.DummyDto, unknown, Types.DummyDto, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.DummyDto, unknown, Types.DummyDto, TContext> {
  const key = nonGetViaPostMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (dto: Types.DummyDto) => Client.nonGetViaPost(dto),
    mutationKey: key,
  });
}
  
export function withBodyUrl(): string {
  let url_ = getBaseUrl() + "/query/WithBody";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let withBodyDefaultOptions: Omit<UseQueryOptions<string, unknown, string>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<string, unknown, string>, 'queryFn'>> = {
};
export function getWithBodyDefaultOptions() {
  return withBodyDefaultOptions;
};
export function setWithBodyDefaultOptions(options: typeof withBodyDefaultOptions) {
  withBodyDefaultOptions = options;
}

export function withBodyQueryKey(dto: Types.BodyDto): QueryKey;
export function withBodyQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { dto,  } = params[0] as WithBodyQueryQueryParameters;

    return trimArrayEnd([
        'QueryClient',
        'withBody',
        dto as any,
      ]);
  } else {
    return trimArrayEnd([
        'QueryClient',
        'withBody',
        ...params
      ]);
  }
}
export function __withBody(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.withBody(
      context.queryKey[2] as Types.BodyDto,axiosConfig    );
}

export function useWithBodyQuery<TSelectData = string, TError = unknown>(dto: WithBodyQueryQueryParameters, options?: Omit<UseQueryOptions<string, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;

export function useWithBodyQuery<TSelectData = string, TError = unknown>(dto: Types.BodyDto, options?: Omit<UseQueryOptions<string, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useWithBodyQuery<TSelectData = string, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<string, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let dto: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ dto,  } = params[0] as WithBodyQueryQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [dto, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<string, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __withBody(context, axiosConfig) : __withBody,
    queryKey: withBodyQueryKey(dto),
    ...withBodyDefaultOptions as unknown as Omit<UseQueryOptions<string, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}

export function setWithBodyData(queryClient: QueryClient, updater: (data: string | undefined) => string, dto: Types.BodyDto) {
  queryClient.setQueryData(withBodyQueryKey(dto),
    updater
  );
}

export function setWithBodyDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: string | undefined) => string) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function withClassInQueryUrl(tst?: string | undefined): string {
  let url_ = getBaseUrl() + "/query/ClassInQuery?";
if (tst === null)
    throw new Error("The parameter 'tst' cannot be null.");
else if (tst !== undefined)
    url_ += "Tst=" + encodeURIComponent("" + tst) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let withClassInQueryDefaultOptions: Omit<UseQueryOptions<string, unknown, string>, 'queryKey' | 'queryFn'> & Partial<Pick<UseQueryOptions<string, unknown, string>, 'queryFn'>> = {
};
export function getWithClassInQueryDefaultOptions() {
  return withClassInQueryDefaultOptions;
};
export function setWithClassInQueryDefaultOptions(options: typeof withClassInQueryDefaultOptions) {
  withClassInQueryDefaultOptions = options;
}

export function withClassInQueryQueryKey(tst?: string | undefined): QueryKey;
export function withClassInQueryQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { tst,  } = params[0] as WithClassInQueryQueryQueryParameters;

    return trimArrayEnd([
        'QueryClient',
        'withClassInQuery',
        tst as any,
      ]);
  } else {
    return trimArrayEnd([
        'QueryClient',
        'withClassInQuery',
        ...params
      ]);
  }
}
export function __withClassInQuery(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client.withClassInQuery(
      context.queryKey[2] as string | undefined,axiosConfig    );
}

export function useWithClassInQueryQuery<TSelectData = string, TError = unknown>(dto: WithClassInQueryQueryQueryParameters, options?: Omit<UseQueryOptions<string, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;

export function useWithClassInQueryQuery<TSelectData = string, TError = unknown>(tst?: string | undefined, options?: Omit<UseQueryOptions<string, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useWithClassInQueryQuery<TSelectData = string, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<string, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let tst: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ tst,  } = params[0] as WithClassInQueryQueryQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [tst, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<string, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __withClassInQuery(context, axiosConfig) : __withClassInQuery,
    queryKey: withClassInQueryQueryKey(tst),
    ...withClassInQueryDefaultOptions as unknown as Omit<UseQueryOptions<string, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}

export function setWithClassInQueryData(queryClient: QueryClient, updater: (data: string | undefined) => string, tst?: string | undefined) {
  queryClient.setQueryData(withClassInQueryQueryKey(tst),
    updater
  );
}

export function setWithClassInQueryDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: string | undefined) => string) {
  queryClient.setQueryData(queryKey, updater);
}
import * as Types from './magadan.types';
export * from './magadan.types';

//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import type { AxiosError } from 'axios';
import type { AxiosInstance, AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

export * as VariableClient from './magadan/VariableClient';

export * as VariableQuery from './magadan/VariableQuery';



export * as UserClient from './magadan/UserClient';

export * as UserQuery from './magadan/UserQuery';



export * as TestApiClient from './magadan/TestApiClient';

export * as TestApiQuery from './magadan/TestApiQuery';



export * as TemplateClient from './magadan/TemplateClient';

export * as TemplateQuery from './magadan/TemplateQuery';



export * as TemplateActionClient from './magadan/TemplateActionClient';

export * as TemplateActionQuery from './magadan/TemplateActionQuery';



export * as PromptClient from './magadan/PromptClient';

export * as PromptQuery from './magadan/PromptQuery';



export * as SignerClient from './magadan/SignerClient';

export * as SignerQuery from './magadan/SignerQuery';



export * as SharePointWebhookClient from './magadan/SharePointWebhookClient';

export * as SharePointWebhookQuery from './magadan/SharePointWebhookQuery';



export * as SettingsClient from './magadan/SettingsClient';

export * as SettingsQuery from './magadan/SettingsQuery';



export * as ReleaseClient from './magadan/ReleaseClient';

export * as ReleaseQuery from './magadan/ReleaseQuery';



export * as ProjectClient from './magadan/ProjectClient';

export * as ProjectQuery from './magadan/ProjectQuery';



export * as ProjectSignerClient from './magadan/ProjectSignerClient';

export * as ProjectSignerQuery from './magadan/ProjectSignerQuery';



export * as ProjectRolesClient from './magadan/ProjectRolesClient';

export * as ProjectRolesQuery from './magadan/ProjectRolesQuery';



export * as ExternalEditingClient from './magadan/ExternalEditingClient';

export * as ExternalEditingQuery from './magadan/ExternalEditingQuery';



export * as EditingLockClient from './magadan/EditingLockClient';

export * as EditingLockQuery from './magadan/EditingLockQuery';



export * as DocumentClient from './magadan/DocumentClient';

export * as DocumentQuery from './magadan/DocumentQuery';



export * as DocumentUtilitiesClient from './magadan/DocumentUtilitiesClient';

export * as DocumentUtilitiesQuery from './magadan/DocumentUtilitiesQuery';



export * as DocumentExportClient from './magadan/DocumentExportClient';

export * as DocumentExportQuery from './magadan/DocumentExportQuery';



export * as DocumentSigningClient from './magadan/DocumentSigningClient';

export * as DocumentSigningQuery from './magadan/DocumentSigningQuery';



export * as ArtificialIntelligenceClient from './magadan/ArtificialIntelligenceClient';

export * as ArtificialIntelligenceQuery from './magadan/ArtificialIntelligenceQuery';



export * as SignUrlClient from './magadan/SignUrlClient';

export * as SignUrlQuery from './magadan/SignUrlQuery';



export * as TestDataClient from './magadan/TestDataClient';

export * as TestDataQuery from './magadan/TestDataQuery';



export * as VersionClient from './magadan/VersionClient';

export * as VersionQuery from './magadan/VersionQuery';





import { addResultTypeFactory } from './magadan/helpers';
export { setBaseUrl, getBaseUrl } from './magadan/helpers';
export { setAxiosFactory, getAxios } from './magadan/helpers';


//-----PersistorHydrator.File-----
import type { PersistedClient } from '@tanstack/react-query-persist-client';
import type { DehydratedState, QueryKey } from '@tanstack/react-query'
import { getResultTypeFactory } from './magadan/helpers';

/*
 * If you have Dates in QueryKeys (i.e. in request parameters), you need to deserialize them to Dates correctly
 * (otherwise they are deserialized as strings by default, and your queries are broken).
 */
export function deserializeDate(str: unknown) {
  if (!str || typeof str !== 'string') return str;
  if (!/^\d\d\d\d\-\d\d\-\d\d/.test(str)) return str;
  
  const date = new Date(str);
  const isDate = date instanceof Date && !isNaN(date as any);
  
  return isDate ? date : str;
}

export function deserializeDatesInQueryKeys(queryKey: QueryKey) {
  return queryKey
    // We need to replace `null` with `undefined` in query key, because
    // `undefined` is serialized as `null`.
    // And most probably if we have `null` in QueryKey it actually means `undefined`.
    // We can't keep nulls, because they have a different meaning, and e.g. boolean parameters are not allowed to be null.
    .map(x => (x === null ? undefined : x))
    .map(x => deserializeDate(x));
}

export function deserializeClassesInQueryData(queryKey: QueryKey, data: any) {
  if (!data) {
    return data;
  } else if (typeof data !== 'object') {
    return data;
  } else if ('pages' in data && 'pageParams' in data && Array.isArray(data.pages) && Array.isArray(data.pageParams)) {
    // infinite query
    data.pages = data.pages.map((page:any) => deserializeClassesInQueryData(queryKey, page));
  } else if (Array.isArray(data)) {
    return data.map(elem => constructDtoClass(queryKey, elem));
  } else {
    return constructDtoClass(queryKey, data);
  }
}

/*
 * Pass this function as `deserialize` option to createSyncStoragePersister/createAsyncStoragePersister
 * to correctly deserialize your DTOs (including Dates)
 */
export function persisterDeserialize(cache: string): PersistedClient {
  const client: PersistedClient = JSON.parse(cache);
  client.clientState.queries.forEach((query) => {
    query.state.data = deserializeClassesInQueryData(query.queryKey, query.state.data);
    query.queryKey = deserializeDatesInQueryKeys(query.queryKey);
  });

  return client;
}

export function constructDtoClass(queryKey: QueryKey, data: any): unknown {
  const resultTypeKey = getResultTypeClassKey(queryKey);
  const constructorFunction = getResultTypeFactory(resultTypeKey);

  if (!data || !constructorFunction)
    return data;

  return constructorFunction(data);
}

export function getResultTypeClassKey(queryKey: QueryKey): string {
  if (!Array.isArray(queryKey)) {
    return queryKey as unknown as string;
  }
  if (queryKey.length >= 2) {
    // We concatenate first and second elements, because they uniquely identify the query.
    // All other QueryKey elements are query parameters
    return `${queryKey[0]}___${queryKey[1]}`;
  }

  // We actually should never reach this point :)
  return queryKey.join('___');
}

export function initPersister() {
  
  addResultTypeFactory('VariableClient___search', (data: any) => Types.initPagedResultOfVariableListItemDto(data));
  addResultTypeFactory('VariableClient___get', (data: any) => Types.initVariableDto(data));


  addResultTypeFactory('UserClient___getCurrentUserInfo', (data: any) => Types.initCurrentUserDto(data));




  addResultTypeFactory('TemplateClient___search', (data: any) => Types.initPagedResultOfTemplateListItemDto(data));
  addResultTypeFactory('TemplateClient___get', (data: any) => Types.initTemplateDto(data));
  addResultTypeFactory('TemplateClient___getDocumentTemplate', (data: any) => Types.initTemplateDto(data));




  addResultTypeFactory('PromptClient___get', (data: any) => Types.initPromptDto(data));
  addResultTypeFactory('PromptClient___getVariableConnections', (data: any) => Types.initPromptVariableConnectionDto(data));


  addResultTypeFactory('SignerClient___search', (data: any) => Types.initPagedResultOfSignerDto(data));
  addResultTypeFactory('SignerClient___get', (data: any) => Types.initSignerDto(data));




  addResultTypeFactory('SettingsClient___settingsDto', (data: any) => Types.initSettingsDto(data));
  addResultTypeFactory('SettingsClient___settingsForSpecificRelease', (data: any) => Types.initSettingsDto(data));


  addResultTypeFactory('ReleaseClient___search', (data: any) => Types.initPagedResultOfReleaseListItemDto(data));
  addResultTypeFactory('ReleaseClient___get', (data: any) => Types.initReleaseDto(data));


  addResultTypeFactory('ProjectClient___search', (data: any) => Types.initPagedResultOfProjectListItemDto(data));
  addResultTypeFactory('ProjectClient___get', (data: any) => Types.initProjectDto(data));


  addResultTypeFactory('ProjectSignerClient___search', (data: any) => Types.initPagedResultOfProjectSignerDto(data));
  addResultTypeFactory('ProjectSignerClient___get', (data: any) => Types.initProjectSignerDto(data));


  addResultTypeFactory('ProjectRolesClient___search', (data: any) => Types.initPagedResultOfProjectRoleDto(data));
  addResultTypeFactory('ProjectRolesClient___get', (data: any) => Types.initProjectRoleDto(data));




  addResultTypeFactory('EditingLockClient___checkLock', (data: any) => Types.initRefDocumentEditingUserDto(data));


  addResultTypeFactory('DocumentClient___get', (data: any) => Types.initDocumentDto(data));
  addResultTypeFactory('DocumentClient___search', (data: any) => Types.initPagedResultOfDocumentListItemDto(data));






  addResultTypeFactory('DocumentSigningClient___getDocumentSignersAvailableRoles', (data: any) => Types.initAvailableRolesDto(data));
  addResultTypeFactory('DocumentSigningClient___getDocumentsSigningStatus', (data: any) => Types.initDocumentSigningStatusDto(data));
  addResultTypeFactory('DocumentSigningClient___getSignerToResendNotifications', (data: any) => Types.initSignerToResendNotificationDto(data));










}
//-----/PersistorHydrator.File----
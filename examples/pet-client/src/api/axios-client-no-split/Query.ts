//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming
import * as Types from '../axios-client-no-split';
import { useQuery, useMutation } from '@tanstack/react-query';
import type { UseQueryResult, QueryFunctionContext, UseQueryOptions, QueryClient, QueryKey, MutationKey, UseMutationOptions, UseMutationResult, QueryMeta, MutationMeta } from '@tanstack/react-query';
import { trimArrayEnd, isParameterObject, getBaseUrl, addMetaToOptions } from './helpers';
import type { QueryMetaContextValue } from 'react-query-swagger';
import { QueryMetaContext } from 'react-query-swagger';
import { useContext } from 'react';
import { Client as ClientClass } from '../axios-client-no-split';
import { createClient, getClientFactory } from './helpers';

export const Client = () => getClientFactory()(ClientClass);
import type { AxiosRequestConfig } from 'axios';

export type UploadFileQueryParameters = {
  petId: number ;
  additionalMetadata: string | null | undefined ;
  file: Types.FileParameter | null | undefined ;
}

export type UploadFileMutationParameters = {
  additionalMetadata: string | null | undefined ;
  file: Types.FileParameter | null | undefined ;
}

export type FindPetsByStatusQueryParameters = {
  status: Types.Status[] ;
}

export type FindPetsByTagsQueryParameters = {
  tags: string[] ;
}

export type GetPetByIdQueryParameters = {
  petId: number ;
}

export type UpdatePetWithFormQueryParameters = {
  petId: number ;
  name: string | null | undefined ;
  status: string | null | undefined ;
}

export type UpdatePetWithFormMutationParameters = {
  name: string | null | undefined ;
  status: string | null | undefined ;
}

export type DeletePetQueryParameters = {
  api_key: string | null | undefined ;
  petId: number ;
}

export type GetOrderByIdQueryParameters = {
  orderId: number ;
}

export type DeleteOrderQueryParameters = {
  orderId: number ;
}


export type GetUserByNameQueryParameters = {
  username: string ;
}

export type UpdateUserQueryParameters = {
  username: string ;
}

export type DeleteUserQueryParameters = {
  username: string ;
}

export type LoginUserQueryParameters = {
  username: string ;
  password: string ;
}

export function uploadFileUrl(petId: number): string {
  let url_ = getBaseUrl() + "/pet/{petId}/uploadImage";
if (petId === undefined || petId === null)
  throw new Error("The parameter 'petId' must be defined.");
url_ = url_.replace("{petId}", encodeURIComponent("" + petId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function uploadFileMutationKey(petId: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'uploadFile',
      petId as any,
    ]);
}

/**
 * uploads an image
 * @param petId ID of pet to update
 * @param additionalMetadata (optional) Additional data to pass to server
 * @param file (optional) file to upload
 * @return successful operation
 */
export function useUploadFileMutation<TContext>(petId: number, options?: Omit<UseMutationOptions<Types.ApiResponse, unknown, UploadFileMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.ApiResponse, unknown, UploadFileMutationParameters, TContext> {
  const key = uploadFileMutationKey(petId);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (uploadFileMutationParameters: UploadFileMutationParameters) => Client().uploadFile(petId, uploadFileMutationParameters.additionalMetadata, uploadFileMutationParameters.file),
    mutationKey: key,
  });
}
  
type UploadFile__MutationParameters = UploadFileQueryParameters & {
  uploadFileMutationParameters: UploadFileMutationParameters;
}

/**
 * uploads an image
 * @param petId ID of pet to update
 * @param additionalMetadata (optional) Additional data to pass to server
 * @param file (optional) file to upload
 * @return successful operation
 */
export function useUploadFileMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<Types.ApiResponse, unknown, UploadFile__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: UploadFileQueryParameters}): UseMutationResult<Types.ApiResponse, unknown, UploadFile__MutationParameters, TContext> {
  const key = uploadFileMutationKey(options?.parameters?.petId!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options, 
    mutationFn: (data: UploadFile__MutationParameters) => Client().uploadFile(data.petId, data.additionalMetadata, data.file),
    mutationKey: key,
  });
}
  
export function addPetUrl(): string {
  let url_ = getBaseUrl() + "/pet";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function addPetMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'addPet',
    ]);
}

/**
 * Add a new pet to the store
 * @param body Pet object that needs to be added to the store
 */
export function useAddPetMutation<TContext>(options?: Omit<UseMutationOptions<void, unknown, Types.Pet, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, Types.Pet, TContext> {
  const key = addPetMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.Pet) => Client().addPet(body),
    mutationKey: key,
  });
}
  
export function updatePetUrl(): string {
  let url_ = getBaseUrl() + "/pet";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function updatePetMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'updatePet',
    ]);
}

/**
 * Update an existing pet
 * @param body Pet object that needs to be added to the store
 */
export function useUpdatePetMutation<TContext>(options?: Omit<UseMutationOptions<void, unknown, Types.Pet, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, Types.Pet, TContext> {
  const key = updatePetMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.Pet) => Client().updatePet(body),
    mutationKey: key,
  });
}
  
export function findPetsByStatusUrl(status: Types.Status[]): string {
  let url_ = getBaseUrl() + "/pet/findByStatus?";
  if (status === undefined || status === null)
    throw new Error("The parameter 'status' must be defined and cannot be null.");
  else
    status && status.forEach(item => { url_ += "status=" + encodeURIComponent("" + item) + "&"; });
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let findPetsByStatusDefaultOptions: Omit<UseQueryOptions<Types.Pet[], unknown, Types.Pet[]>, 'queryKey'> = {
  queryFn: __findPetsByStatus,
};
export function getFindPetsByStatusDefaultOptions() {
  return findPetsByStatusDefaultOptions;
};
export function setFindPetsByStatusDefaultOptions(options: typeof findPetsByStatusDefaultOptions) {
  findPetsByStatusDefaultOptions = options;
}

export function findPetsByStatusQueryKey(status: Types.Status[]): QueryKey;
export function findPetsByStatusQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { status,  } = params[0] as FindPetsByStatusQueryParameters;

    return trimArrayEnd([
        'Client',
        'findPetsByStatus',
        status as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'findPetsByStatus',
        ...params
      ]);
  }
}
function __findPetsByStatus(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().findPetsByStatus(
      context.queryKey[2] as Types.Status[]);
}

export function useFindPetsByStatusQuery<TSelectData = Types.Pet[], TError = unknown>(dto: FindPetsByStatusQueryParameters, options?: Omit<UseQueryOptions<Types.Pet[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Finds Pets by status
 * @param status Status values that need to be considered for filter
 * @return successful operation
 */
export function useFindPetsByStatusQuery<TSelectData = Types.Pet[], TError = unknown>(status: Types.Status[], options?: Omit<UseQueryOptions<Types.Pet[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useFindPetsByStatusQuery<TSelectData = Types.Pet[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.Pet[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let status: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ status,  } = params[0] as FindPetsByStatusQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [status, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.Pet[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __findPetsByStatus(context, axiosConfig) : __findPetsByStatus,
    queryKey: findPetsByStatusQueryKey(status),
    ...findPetsByStatusDefaultOptions as unknown as Omit<UseQueryOptions<Types.Pet[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Finds Pets by status
 * @param status Status values that need to be considered for filter
 * @return successful operation
 */
export function setFindPetsByStatusData(queryClient: QueryClient, updater: (data: Types.Pet[] | undefined) => Types.Pet[], status: Types.Status[]) {
  queryClient.setQueryData(findPetsByStatusQueryKey(status),
    updater
  );
}

/**
 * Finds Pets by status
 * @param status Status values that need to be considered for filter
 * @return successful operation
 */
export function setFindPetsByStatusDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.Pet[] | undefined) => Types.Pet[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function findPetsByTagsUrl(tags: string[]): string {
  let url_ = getBaseUrl() + "/pet/findByTags?";
  if (tags === undefined || tags === null)
    throw new Error("The parameter 'tags' must be defined and cannot be null.");
  else
    tags && tags.forEach(item => { url_ += "tags=" + encodeURIComponent("" + item) + "&"; });
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let findPetsByTagsDefaultOptions: Omit<UseQueryOptions<Types.Pet[], unknown, Types.Pet[]>, 'queryKey'> = {
  queryFn: __findPetsByTags,
};
export function getFindPetsByTagsDefaultOptions() {
  return findPetsByTagsDefaultOptions;
};
export function setFindPetsByTagsDefaultOptions(options: typeof findPetsByTagsDefaultOptions) {
  findPetsByTagsDefaultOptions = options;
}

export function findPetsByTagsQueryKey(tags: string[]): QueryKey;
export function findPetsByTagsQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { tags,  } = params[0] as FindPetsByTagsQueryParameters;

    return trimArrayEnd([
        'Client',
        'findPetsByTags',
        tags as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'findPetsByTags',
        ...params
      ]);
  }
}
function __findPetsByTags(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().findPetsByTags(
      context.queryKey[2] as string[]);
}

export function useFindPetsByTagsQuery<TSelectData = Types.Pet[], TError = unknown>(dto: FindPetsByTagsQueryParameters, options?: Omit<UseQueryOptions<Types.Pet[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Finds Pets by tags
 * @param tags Tags to filter by
 * @return successful operation
 * @deprecated
 */
export function useFindPetsByTagsQuery<TSelectData = Types.Pet[], TError = unknown>(tags: string[], options?: Omit<UseQueryOptions<Types.Pet[], TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useFindPetsByTagsQuery<TSelectData = Types.Pet[], TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.Pet[], TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let tags: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ tags,  } = params[0] as FindPetsByTagsQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [tags, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.Pet[], TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __findPetsByTags(context, axiosConfig) : __findPetsByTags,
    queryKey: findPetsByTagsQueryKey(tags),
    ...findPetsByTagsDefaultOptions as unknown as Omit<UseQueryOptions<Types.Pet[], TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Finds Pets by tags
 * @param tags Tags to filter by
 * @return successful operation
 * @deprecated
 */
export function setFindPetsByTagsData(queryClient: QueryClient, updater: (data: Types.Pet[] | undefined) => Types.Pet[], tags: string[]) {
  queryClient.setQueryData(findPetsByTagsQueryKey(tags),
    updater
  );
}

/**
 * Finds Pets by tags
 * @param tags Tags to filter by
 * @return successful operation
 * @deprecated
 */
export function setFindPetsByTagsDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.Pet[] | undefined) => Types.Pet[]) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function getPetByIdUrl(petId: number): string {
  let url_ = getBaseUrl() + "/pet/{petId}";
if (petId === undefined || petId === null)
  throw new Error("The parameter 'petId' must be defined.");
url_ = url_.replace("{petId}", encodeURIComponent("" + petId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getPetByIdDefaultOptions: Omit<UseQueryOptions<Types.Pet, unknown, Types.Pet>, 'queryKey'> = {
  queryFn: __getPetById,
};
export function getGetPetByIdDefaultOptions() {
  return getPetByIdDefaultOptions;
};
export function setGetPetByIdDefaultOptions(options: typeof getPetByIdDefaultOptions) {
  getPetByIdDefaultOptions = options;
}

export function getPetByIdQueryKey(petId: number): QueryKey;
export function getPetByIdQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { petId,  } = params[0] as GetPetByIdQueryParameters;

    return trimArrayEnd([
        'Client',
        'getPetById',
        petId as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'getPetById',
        ...params
      ]);
  }
}
function __getPetById(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().getPetById(
      context.queryKey[2] as number);
}

export function useGetPetByIdQuery<TSelectData = Types.Pet, TError = unknown>(dto: GetPetByIdQueryParameters, options?: Omit<UseQueryOptions<Types.Pet, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Find pet by ID
 * @param petId ID of pet to return
 * @return successful operation
 */
export function useGetPetByIdQuery<TSelectData = Types.Pet, TError = unknown>(petId: number, options?: Omit<UseQueryOptions<Types.Pet, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useGetPetByIdQuery<TSelectData = Types.Pet, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.Pet, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let petId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ petId,  } = params[0] as GetPetByIdQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [petId, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.Pet, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __getPetById(context, axiosConfig) : __getPetById,
    queryKey: getPetByIdQueryKey(petId),
    ...getPetByIdDefaultOptions as unknown as Omit<UseQueryOptions<Types.Pet, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Find pet by ID
 * @param petId ID of pet to return
 * @return successful operation
 */
export function setGetPetByIdData(queryClient: QueryClient, updater: (data: Types.Pet | undefined) => Types.Pet, petId: number) {
  queryClient.setQueryData(getPetByIdQueryKey(petId),
    updater
  );
}

/**
 * Find pet by ID
 * @param petId ID of pet to return
 * @return successful operation
 */
export function setGetPetByIdDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.Pet | undefined) => Types.Pet) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function updatePetWithFormUrl(petId: number): string {
  let url_ = getBaseUrl() + "/pet/{petId}";
if (petId === undefined || petId === null)
  throw new Error("The parameter 'petId' must be defined.");
url_ = url_.replace("{petId}", encodeURIComponent("" + petId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function updatePetWithFormMutationKey(petId: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'updatePetWithForm',
      petId as any,
    ]);
}

/**
 * Updates a pet in the store with form data
 * @param petId ID of pet that needs to be updated
 * @param name (optional) Updated name of the pet
 * @param status (optional) Updated status of the pet
 */
export function useUpdatePetWithFormMutation<TContext>(petId: number, options?: Omit<UseMutationOptions<void, unknown, UpdatePetWithFormMutationParameters, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, UpdatePetWithFormMutationParameters, TContext> {
  const key = updatePetWithFormMutationKey(petId);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (updatePetWithFormMutationParameters: UpdatePetWithFormMutationParameters) => Client().updatePetWithForm(petId, updatePetWithFormMutationParameters.name, updatePetWithFormMutationParameters.status),
    mutationKey: key,
  });
}
  
type UpdatePetWithForm__MutationParameters = UpdatePetWithFormQueryParameters & {
  updatePetWithFormMutationParameters: UpdatePetWithFormMutationParameters;
}

/**
 * Updates a pet in the store with form data
 * @param petId ID of pet that needs to be updated
 * @param name (optional) Updated name of the pet
 * @param status (optional) Updated status of the pet
 */
export function useUpdatePetWithFormMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, UpdatePetWithForm__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: UpdatePetWithFormQueryParameters}): UseMutationResult<void, unknown, UpdatePetWithForm__MutationParameters, TContext> {
  const key = updatePetWithFormMutationKey(options?.parameters?.petId!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options, 
    mutationFn: (data: UpdatePetWithForm__MutationParameters) => Client().updatePetWithForm(data.petId, data.name, data.status),
    mutationKey: key,
  });
}
  
export function deletePetUrl(petId: number, api_key: string | null | undefined): string {
  let url_ = getBaseUrl() + "/pet/{petId}";
if (petId === undefined || petId === null)
  throw new Error("The parameter 'petId' must be defined.");
url_ = url_.replace("{petId}", encodeURIComponent("" + petId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function deletePetMutationKey(petId: number, api_key: string | null | undefined): MutationKey {
  return trimArrayEnd([
      'Client',
      'deletePet',
      petId as any,
      api_key as any,
    ]);
}

/**
 * Deletes a pet
 * @param api_key (optional) 
 * @param petId Pet id to delete
 */
export function useDeletePetMutation<TContext>(petId: number, api_key: string | null | undefined, options?: Omit<UseMutationOptions<void, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, void, TContext> {
  const key = deletePetMutationKey(petId, api_key);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client().deletePet(api_key, petId),
    mutationKey: key,
  });
}
  
type DeletePet__MutationParameters = DeletePetQueryParameters

/**
 * Deletes a pet
 * @param api_key (optional) 
 * @param petId Pet id to delete
 */
export function useDeletePetMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, DeletePet__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: DeletePetQueryParameters}): UseMutationResult<void, unknown, DeletePet__MutationParameters, TContext> {
  const key = deletePetMutationKey(options?.parameters?.petId!, options?.parameters?.api_key!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: DeletePet__MutationParameters) => Client().deletePet(data.api_key ?? options?.parameters?.api_key!, data.petId ?? options?.parameters?.petId!),
  mutationKey: key,
});
}
  
export function placeOrderUrl(): string {
  let url_ = getBaseUrl() + "/store/order";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function placeOrderMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'placeOrder',
    ]);
}

/**
 * Place an order for a pet
 * @param body order placed for purchasing the pet
 * @return successful operation
 */
export function usePlaceOrderMutation<TContext>(options?: Omit<UseMutationOptions<Types.Order, unknown, Types.Order, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<Types.Order, unknown, Types.Order, TContext> {
  const key = placeOrderMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.Order) => Client().placeOrder(body),
    mutationKey: key,
  });
}
  
export function getOrderByIdUrl(orderId: number): string {
  let url_ = getBaseUrl() + "/store/order/{orderId}";
if (orderId === undefined || orderId === null)
  throw new Error("The parameter 'orderId' must be defined.");
url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getOrderByIdDefaultOptions: Omit<UseQueryOptions<Types.Order, unknown, Types.Order>, 'queryKey'> = {
  queryFn: __getOrderById,
};
export function getGetOrderByIdDefaultOptions() {
  return getOrderByIdDefaultOptions;
};
export function setGetOrderByIdDefaultOptions(options: typeof getOrderByIdDefaultOptions) {
  getOrderByIdDefaultOptions = options;
}

export function getOrderByIdQueryKey(orderId: number): QueryKey;
export function getOrderByIdQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { orderId,  } = params[0] as GetOrderByIdQueryParameters;

    return trimArrayEnd([
        'Client',
        'getOrderById',
        orderId as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'getOrderById',
        ...params
      ]);
  }
}
function __getOrderById(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().getOrderById(
      context.queryKey[2] as number);
}

export function useGetOrderByIdQuery<TSelectData = Types.Order, TError = unknown>(dto: GetOrderByIdQueryParameters, options?: Omit<UseQueryOptions<Types.Order, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Find purchase order by ID
 * @param orderId ID of pet that needs to be fetched
 * @return successful operation
 */
export function useGetOrderByIdQuery<TSelectData = Types.Order, TError = unknown>(orderId: number, options?: Omit<UseQueryOptions<Types.Order, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useGetOrderByIdQuery<TSelectData = Types.Order, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.Order, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let orderId: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ orderId,  } = params[0] as GetOrderByIdQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [orderId, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.Order, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __getOrderById(context, axiosConfig) : __getOrderById,
    queryKey: getOrderByIdQueryKey(orderId),
    ...getOrderByIdDefaultOptions as unknown as Omit<UseQueryOptions<Types.Order, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Find purchase order by ID
 * @param orderId ID of pet that needs to be fetched
 * @return successful operation
 */
export function setGetOrderByIdData(queryClient: QueryClient, updater: (data: Types.Order | undefined) => Types.Order, orderId: number) {
  queryClient.setQueryData(getOrderByIdQueryKey(orderId),
    updater
  );
}

/**
 * Find purchase order by ID
 * @param orderId ID of pet that needs to be fetched
 * @return successful operation
 */
export function setGetOrderByIdDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.Order | undefined) => Types.Order) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function deleteOrderUrl(orderId: number): string {
  let url_ = getBaseUrl() + "/store/order/{orderId}";
if (orderId === undefined || orderId === null)
  throw new Error("The parameter 'orderId' must be defined.");
url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function deleteOrderMutationKey(orderId: number): MutationKey {
  return trimArrayEnd([
      'Client',
      'deleteOrder',
      orderId as any,
    ]);
}

/**
 * Delete purchase order by ID
 * @param orderId ID of the order that needs to be deleted
 */
export function useDeleteOrderMutation<TContext>(orderId: number, options?: Omit<UseMutationOptions<void, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, void, TContext> {
  const key = deleteOrderMutationKey(orderId);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client().deleteOrder(orderId),
    mutationKey: key,
  });
}
  
type DeleteOrder__MutationParameters = DeleteOrderQueryParameters

/**
 * Delete purchase order by ID
 * @param orderId ID of the order that needs to be deleted
 */
export function useDeleteOrderMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, DeleteOrder__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: DeleteOrderQueryParameters}): UseMutationResult<void, unknown, DeleteOrder__MutationParameters, TContext> {
  const key = deleteOrderMutationKey(options?.parameters?.orderId!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: DeleteOrder__MutationParameters) => Client().deleteOrder(data.orderId ?? options?.parameters?.orderId!),
  mutationKey: key,
});
}
  
export function getInventoryUrl(): string {
  let url_ = getBaseUrl() + "/store/inventory";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getInventoryDefaultOptions: Omit<UseQueryOptions<{ [key: string]: number; }, unknown, { [key: string]: number; }>, 'queryKey'> = {
  queryFn: __getInventory,
};
export function getGetInventoryDefaultOptions() {
  return getInventoryDefaultOptions;
};
export function setGetInventoryDefaultOptions(options: typeof getInventoryDefaultOptions) {
  getInventoryDefaultOptions = options;
}

export function getInventoryQueryKey(): QueryKey;
export function getInventoryQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'getInventory',
    ]);
}
function __getInventory(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().getInventory(
);
}

/**
 * Returns pet inventories by status
 * @return successful operation
 */
export function useGetInventoryQuery<TSelectData = { [key: string]: number; }, TError = unknown>(options?: Omit<UseQueryOptions<{ [key: string]: number; }, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useGetInventoryQuery<TSelectData = { [key: string]: number; }, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<{ [key: string]: number; }, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<{ [key: string]: number; }, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __getInventory(context, axiosConfig) : __getInventory,
    queryKey: getInventoryQueryKey(),
    ...getInventoryDefaultOptions as unknown as Omit<UseQueryOptions<{ [key: string]: number; }, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Returns pet inventories by status
 * @return successful operation
 */
export function setGetInventoryData(queryClient: QueryClient, updater: (data: { [key: string]: number; } | undefined) => { [key: string]: number; }, ) {
  queryClient.setQueryData(getInventoryQueryKey(),
    updater
  );
}

/**
 * Returns pet inventories by status
 * @return successful operation
 */
export function setGetInventoryDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: { [key: string]: number; } | undefined) => { [key: string]: number; }) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function createUsersWithArrayInputUrl(): string {
  let url_ = getBaseUrl() + "/user/createWithArray";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function createUsersWithArrayInputMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'createUsersWithArrayInput',
    ]);
}

/**
 * Creates list of users with given input array
 * @param body List of user object
 * @return successful operation
 */
export function useCreateUsersWithArrayInputMutation<TContext>(options?: Omit<UseMutationOptions<void, unknown, Types.User[], TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, Types.User[], TContext> {
  const key = createUsersWithArrayInputMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.User[]) => Client().createUsersWithArrayInput(body),
    mutationKey: key,
  });
}
  
export function createUsersWithListInputUrl(): string {
  let url_ = getBaseUrl() + "/user/createWithList";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function createUsersWithListInputMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'createUsersWithListInput',
    ]);
}

/**
 * Creates list of users with given input array
 * @param body List of user object
 * @return successful operation
 */
export function useCreateUsersWithListInputMutation<TContext>(options?: Omit<UseMutationOptions<void, unknown, Types.User[], TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, Types.User[], TContext> {
  const key = createUsersWithListInputMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.User[]) => Client().createUsersWithListInput(body),
    mutationKey: key,
  });
}
  
export function getUserByNameUrl(username: string): string {
  let url_ = getBaseUrl() + "/user/{username}";
if (username === undefined || username === null)
  throw new Error("The parameter 'username' must be defined.");
url_ = url_.replace("{username}", encodeURIComponent("" + username));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let getUserByNameDefaultOptions: Omit<UseQueryOptions<Types.User, unknown, Types.User>, 'queryKey'> = {
  queryFn: __getUserByName,
};
export function getGetUserByNameDefaultOptions() {
  return getUserByNameDefaultOptions;
};
export function setGetUserByNameDefaultOptions(options: typeof getUserByNameDefaultOptions) {
  getUserByNameDefaultOptions = options;
}

export function getUserByNameQueryKey(username: string): QueryKey;
export function getUserByNameQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { username,  } = params[0] as GetUserByNameQueryParameters;

    return trimArrayEnd([
        'Client',
        'getUserByName',
        username as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'getUserByName',
        ...params
      ]);
  }
}
function __getUserByName(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().getUserByName(
      context.queryKey[2] as string);
}

export function useGetUserByNameQuery<TSelectData = Types.User, TError = unknown>(dto: GetUserByNameQueryParameters, options?: Omit<UseQueryOptions<Types.User, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Get user by user name
 * @param username The name that needs to be fetched. Use user1 for testing.
 * @return successful operation
 */
export function useGetUserByNameQuery<TSelectData = Types.User, TError = unknown>(username: string, options?: Omit<UseQueryOptions<Types.User, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useGetUserByNameQuery<TSelectData = Types.User, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<Types.User, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let username: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ username,  } = params[0] as GetUserByNameQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [username, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<Types.User, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __getUserByName(context, axiosConfig) : __getUserByName,
    queryKey: getUserByNameQueryKey(username),
    ...getUserByNameDefaultOptions as unknown as Omit<UseQueryOptions<Types.User, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Get user by user name
 * @param username The name that needs to be fetched. Use user1 for testing.
 * @return successful operation
 */
export function setGetUserByNameData(queryClient: QueryClient, updater: (data: Types.User | undefined) => Types.User, username: string) {
  queryClient.setQueryData(getUserByNameQueryKey(username),
    updater
  );
}

/**
 * Get user by user name
 * @param username The name that needs to be fetched. Use user1 for testing.
 * @return successful operation
 */
export function setGetUserByNameDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: Types.User | undefined) => Types.User) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function updateUserUrl(username: string): string {
  let url_ = getBaseUrl() + "/user/{username}";
if (username === undefined || username === null)
  throw new Error("The parameter 'username' must be defined.");
url_ = url_.replace("{username}", encodeURIComponent("" + username));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function updateUserMutationKey(username: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'updateUser',
      username as any,
    ]);
}

/**
 * Updated user
 * @param username name that need to be updated
 * @param body Updated user object
 */
export function useUpdateUserMutation<TContext>(username: string, options?: Omit<UseMutationOptions<void, unknown, Types.User, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, Types.User, TContext> {
  const key = updateUserMutationKey(username);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.User) => Client().updateUser(username, body),
    mutationKey: key,
  });
}
  
type UpdateUser__MutationParameters = UpdateUserQueryParameters & {
  body: Types.User;
}

/**
 * Updated user
 * @param username name that need to be updated
 * @param body Updated user object
 */
export function useUpdateUserMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, UpdateUser__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: UpdateUserQueryParameters}): UseMutationResult<void, unknown, UpdateUser__MutationParameters, TContext> {
  const key = updateUserMutationKey(options?.parameters?.username!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: UpdateUser__MutationParameters) => Client().updateUser(data.username ?? options?.parameters?.username!, data.body),
  mutationKey: key,
});
}
  
export function deleteUserUrl(username: string): string {
  let url_ = getBaseUrl() + "/user/{username}";
if (username === undefined || username === null)
  throw new Error("The parameter 'username' must be defined.");
url_ = url_.replace("{username}", encodeURIComponent("" + username));
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function deleteUserMutationKey(username: string): MutationKey {
  return trimArrayEnd([
      'Client',
      'deleteUser',
      username as any,
    ]);
}

/**
 * Delete user
 * @param username The name that needs to be deleted
 */
export function useDeleteUserMutation<TContext>(username: string, options?: Omit<UseMutationOptions<void, unknown, void, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, void, TContext> {
  const key = deleteUserMutationKey(username);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: () => Client().deleteUser(username),
    mutationKey: key,
  });
}
  
type DeleteUser__MutationParameters = DeleteUserQueryParameters

/**
 * Delete user
 * @param username The name that needs to be deleted
 */
export function useDeleteUserMutationWithParameters<TContext>(options?: Omit<UseMutationOptions<void, unknown, DeleteUser__MutationParameters, TContext>, 'mutationKey' | 'mutationFn'> & { parameters?: DeleteUserQueryParameters}): UseMutationResult<void, unknown, DeleteUser__MutationParameters, TContext> {
  const key = deleteUserMutationKey(options?.parameters?.username!);
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
return useMutation({
  ...options, 
  mutationFn: (data: DeleteUser__MutationParameters) => Client().deleteUser(data.username ?? options?.parameters?.username!),
  mutationKey: key,
});
}
  
export function loginUserUrl(username: string, password: string): string {
  let url_ = getBaseUrl() + "/user/login?";
  if (username === undefined || username === null)
    throw new Error("The parameter 'username' must be defined and cannot be null.");
  else
    url_ += "username=" + encodeURIComponent("" + username) + "&";
  if (password === undefined || password === null)
    throw new Error("The parameter 'password' must be defined and cannot be null.");
  else
    url_ += "password=" + encodeURIComponent("" + password) + "&";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let loginUserDefaultOptions: Omit<UseQueryOptions<string, unknown, string>, 'queryKey'> = {
  queryFn: __loginUser,
};
export function getLoginUserDefaultOptions() {
  return loginUserDefaultOptions;
};
export function setLoginUserDefaultOptions(options: typeof loginUserDefaultOptions) {
  loginUserDefaultOptions = options;
}

export function loginUserQueryKey(dto: LoginUserQueryParameters): QueryKey;
export function loginUserQueryKey(username: string, password: string): QueryKey;
export function loginUserQueryKey(...params: any[]): QueryKey {
  if (params.length === 1 && isParameterObject(params[0])) {
    const { username, password,  } = params[0] as LoginUserQueryParameters;

    return trimArrayEnd([
        'Client',
        'loginUser',
        username as any,
        password as any,
      ]);
  } else {
    return trimArrayEnd([
        'Client',
        'loginUser',
        ...params
      ]);
  }
}
function __loginUser(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().loginUser(
      context.queryKey[2] as string,       context.queryKey[3] as string);
}

export function useLoginUserQuery<TSelectData = string, TError = unknown>(dto: LoginUserQueryParameters, options?: Omit<UseQueryOptions<string, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
/**
 * Logs user into the system
 * @param username The user name for login
 * @param password The password for login in clear text
 * @return successful operation
 */
export function useLoginUserQuery<TSelectData = string, TError = unknown>(username: string, password: string, options?: Omit<UseQueryOptions<string, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useLoginUserQuery<TSelectData = string, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<string, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  let username: any = undefined;
  let password: any = undefined;
  
  if (params.length > 0) {
    if (isParameterObject(params[0])) {
      ({ username, password,  } = params[0] as LoginUserQueryParameters);
      options = params[1];
      axiosConfig = params[2];
    } else {
      [username, password, options, axiosConfig] = params;
    }
  }

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<string, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __loginUser(context, axiosConfig) : __loginUser,
    queryKey: loginUserQueryKey(username, password),
    ...loginUserDefaultOptions as unknown as Omit<UseQueryOptions<string, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Logs user into the system
 * @param username The user name for login
 * @param password The password for login in clear text
 * @return successful operation
 */
export function setLoginUserData(queryClient: QueryClient, updater: (data: string | undefined) => string, username: string, password: string) {
  queryClient.setQueryData(loginUserQueryKey(username, password),
    updater
  );
}

/**
 * Logs user into the system
 * @param username The user name for login
 * @param password The password for login in clear text
 * @return successful operation
 */
export function setLoginUserDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: string | undefined) => string) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function logoutUserUrl(): string {
  let url_ = getBaseUrl() + "/user/logout";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

let logoutUserDefaultOptions: Omit<UseQueryOptions<void, unknown, void>, 'queryKey'> = {
  queryFn: __logoutUser,
};
export function getLogoutUserDefaultOptions() {
  return logoutUserDefaultOptions;
};
export function setLogoutUserDefaultOptions(options: typeof logoutUserDefaultOptions) {
  logoutUserDefaultOptions = options;
}

export function logoutUserQueryKey(): QueryKey;
export function logoutUserQueryKey(...params: any[]): QueryKey {
  return trimArrayEnd([
      'Client',
      'logoutUser',
    ]);
}
function __logoutUser(context: QueryFunctionContext, axiosConfig?: AxiosRequestConfig | undefined) {
  return Client().logoutUser(
);
}

/**
 * Logs out current logged in user session
 * @return successful operation
 */
export function useLogoutUserQuery<TSelectData = void, TError = unknown>(options?: Omit<UseQueryOptions<void, TError, TSelectData>, 'queryKey'>, axiosConfig?: Partial<AxiosRequestConfig>): UseQueryResult<TSelectData, TError>;
export function useLogoutUserQuery<TSelectData = void, TError = unknown>(...params: any []): UseQueryResult<TSelectData, TError> {
  let options: UseQueryOptions<void, TError, TSelectData> | undefined = undefined;
  let axiosConfig: AxiosRequestConfig |undefined = undefined;
  

  options = params[0] as any;
  axiosConfig = params[1] as any;

  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);

  return useQuery<void, TError, TSelectData>({
    queryFn: axiosConfig ? (context) => __logoutUser(context, axiosConfig) : __logoutUser,
    queryKey: logoutUserQueryKey(),
    ...logoutUserDefaultOptions as unknown as Omit<UseQueryOptions<void, TError, TSelectData>, 'queryKey'>,
    ...options,
  });
}
/**
 * Logs out current logged in user session
 * @return successful operation
 */
export function setLogoutUserData(queryClient: QueryClient, updater: (data: void | undefined) => void, ) {
  queryClient.setQueryData(logoutUserQueryKey(),
    updater
  );
}

/**
 * Logs out current logged in user session
 * @return successful operation
 */
export function setLogoutUserDataByQueryId(queryClient: QueryClient, queryKey: QueryKey, updater: (data: void | undefined) => void) {
  queryClient.setQueryData(queryKey, updater);
}
    
export function createUserUrl(): string {
  let url_ = getBaseUrl() + "/user";
  url_ = url_.replace(/[?&]$/, "");
  return url_;
}

export function createUserMutationKey(): MutationKey {
  return trimArrayEnd([
      'Client',
      'createUser',
    ]);
}

/**
 * Create user
 * @param body Created user object
 * @return successful operation
 */
export function useCreateUserMutation<TContext>(options?: Omit<UseMutationOptions<void, unknown, Types.User, TContext>, 'mutationKey' | 'mutationFn'>): UseMutationResult<void, unknown, Types.User, TContext> {
  const key = createUserMutationKey();
  
  const metaContext = useContext(QueryMetaContext);
  options = addMetaToOptions(options, metaContext);
  
  return useMutation({
    ...options,
    mutationFn: (body: Types.User) => Client().createUser(body),
    mutationKey: key,
  });
}
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.18.2.0 (NJsonSchema v10.8.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming
import * as Types from '../no-hooks-client-axios';
import type { AxiosRequestConfig, AxiosResponse, CancelToken } from 'axios';

import { throwException, isAxiosError } from '../no-hooks-client-axios';
import { getAxios, getBaseUrl } from './helpers';

/**
 * uploads an image
 * @param petId ID of pet to update
 * @param additionalMetadata (optional) Additional data to pass to server
 * @param file (optional) file to upload
 * @return successful operation
 */
export function uploadFile(petId: number, additionalMetadata?: string | null | undefined, file?: Types.FileParameter | null | undefined , cancelToken?: CancelToken | undefined): Promise<Types.ApiResponse> {
    let url_ = getBaseUrl() + "/pet/{petId}/uploadImage";

    if (petId === undefined || petId === null)
      throw new Error("The parameter 'petId' must be defined.");
    url_ = url_.replace("{petId}", encodeURIComponent("" + petId));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (additionalMetadata !== null && additionalMetadata !== undefined)
        content_.append("additionalMetadata", additionalMetadata.toString());
    if (file !== null && file !== undefined)
        content_.append("file", file.data, file.fileName ? file.fileName : "file");

    let options_: AxiosRequestConfig = {
        ..._requestConfigUploadFile,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            "Accept": "application/json"
        },
        cancelToken
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processUploadFile(_response);
    });
}

function processUploadFile(response: AxiosResponse): Promise<Types.ApiResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.ApiResponse.fromJS(resultData200);
        return Promise.resolve<Types.ApiResponse>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.ApiResponse>(null as any);
}

/**
 * Add a new pet to the store
 * @param body Pet object that needs to be added to the store
 */
export function addPet(body: Types.Pet , cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/pet";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigAddPet,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            "Content-Type": "application/json",
        },
        cancelToken
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processAddPet(_response);
    });
}

function processAddPet(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 405) {
        const _responseText = response.data;
        return throwException("Invalid input", status, _responseText, _headers);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}

/**
 * Update an existing pet
 * @param body Pet object that needs to be added to the store
 */
export function updatePet(body: Types.Pet , cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/pet";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigUpdatePet,
        data: content_,
        method: "PUT",
        url: url_,
        headers: {
            "Content-Type": "application/json",
        },
        cancelToken
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processUpdatePet(_response);
    });
}

function processUpdatePet(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 400) {
        const _responseText = response.data;
        return throwException("Invalid ID supplied", status, _responseText, _headers);

    } else if (status === 404) {
        const _responseText = response.data;
        return throwException("Pet not found", status, _responseText, _headers);

    } else if (status === 405) {
        const _responseText = response.data;
        return throwException("Validation exception", status, _responseText, _headers);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}

/**
 * Finds Pets by status
 * @param status Status values that need to be considered for filter
 * @return successful operation
 */
export function findPetsByStatus(status: Types.Status[] , cancelToken?: CancelToken | undefined): Promise<Types.Pet[]> {
    let url_ = getBaseUrl() + "/pet/findByStatus?";
      if (status === undefined || status === null)
        throw new Error("The parameter 'status' must be defined and cannot be null.");
      else
        status && status.forEach(item => { url_ += "status=" + encodeURIComponent("" + item) + "&"; });
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigFindPetsByStatus,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "application/json"
        },
        cancelToken
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processFindPetsByStatus(_response);
    });
}

function processFindPetsByStatus(response: AxiosResponse): Promise<Types.Pet[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.Pet.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.Pet[]>(result200);

    } else if (status === 400) {
        const _responseText = response.data;
        return throwException("Invalid status value", status, _responseText, _headers);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.Pet[]>(null as any);
}

/**
 * Finds Pets by tags
 * @param tags Tags to filter by
 * @return successful operation
 * @deprecated
 */
export function findPetsByTags(tags: string[] , cancelToken?: CancelToken | undefined): Promise<Types.Pet[]> {
    let url_ = getBaseUrl() + "/pet/findByTags?";
      if (tags === undefined || tags === null)
        throw new Error("The parameter 'tags' must be defined and cannot be null.");
      else
        tags && tags.forEach(item => { url_ += "tags=" + encodeURIComponent("" + item) + "&"; });
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigFindPetsByTags,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "application/json"
        },
        cancelToken
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processFindPetsByTags(_response);
    });
}

function processFindPetsByTags(response: AxiosResponse): Promise<Types.Pet[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (Array.isArray(resultData200)) {
            result200 = [] as any;
            for (let item of resultData200)
                result200!.push(Types.Pet.fromJS(item));
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<Types.Pet[]>(result200);

    } else if (status === 400) {
        const _responseText = response.data;
        return throwException("Invalid tag value", status, _responseText, _headers);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.Pet[]>(null as any);
}

/**
 * Find pet by ID
 * @param petId ID of pet to return
 * @return successful operation
 */
export function getPetById(petId: number , cancelToken?: CancelToken | undefined): Promise<Types.Pet> {
    let url_ = getBaseUrl() + "/pet/{petId}";

    if (petId === undefined || petId === null)
      throw new Error("The parameter 'petId' must be defined.");
    url_ = url_.replace("{petId}", encodeURIComponent("" + petId));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigGetPetById,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "application/json"
        },
        cancelToken
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processGetPetById(_response);
    });
}

function processGetPetById(response: AxiosResponse): Promise<Types.Pet> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.Pet.fromJS(resultData200);
        return Promise.resolve<Types.Pet>(result200);

    } else if (status === 400) {
        const _responseText = response.data;
        return throwException("Invalid ID supplied", status, _responseText, _headers);

    } else if (status === 404) {
        const _responseText = response.data;
        return throwException("Pet not found", status, _responseText, _headers);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.Pet>(null as any);
}

/**
 * Updates a pet in the store with form data
 * @param petId ID of pet that needs to be updated
 * @param name (optional) Updated name of the pet
 * @param status (optional) Updated status of the pet
 */
export function updatePetWithForm(petId: number, name?: string | null | undefined, status?: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/pet/{petId}";

    if (petId === undefined || petId === null)
      throw new Error("The parameter 'petId' must be defined.");
    url_ = url_.replace("{petId}", encodeURIComponent("" + petId));
      url_ = url_.replace(/[?&]$/, "");

    let content_ = "";
    if (name !== undefined)
        content_ += encodeURIComponent("name") + "=" + encodeURIComponent("" + name) + "&";
    if (status !== undefined)
        content_ += encodeURIComponent("status") + "=" + encodeURIComponent("" + status) + "&";
    content_ = content_.replace(/&$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigUpdatePetWithForm,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            "Content-Type": "application/x-www-form-urlencoded",
        },
        cancelToken
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processUpdatePetWithForm(_response);
    });
}

function processUpdatePetWithForm(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 405) {
        const _responseText = response.data;
        return throwException("Invalid input", status, _responseText, _headers);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}

/**
 * Deletes a pet
 * @param petId Pet id to delete
 * @param api_key (optional) 
 */
export function deletePet(petId: number, api_key?: string | null | undefined , cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/pet/{petId}";

    if (petId === undefined || petId === null)
      throw new Error("The parameter 'petId' must be defined.");
    url_ = url_.replace("{petId}", encodeURIComponent("" + petId));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigDeletePet,
        method: "DELETE",
        url: url_,
        headers: {
            "api_key": api_key !== undefined && api_key !== null ? "" + api_key : "",
        },
        cancelToken
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processDeletePet(_response);
    });
}

function processDeletePet(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 400) {
        const _responseText = response.data;
        return throwException("Invalid ID supplied", status, _responseText, _headers);

    } else if (status === 404) {
        const _responseText = response.data;
        return throwException("Pet not found", status, _responseText, _headers);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}

/**
 * Place an order for a pet
 * @param body order placed for purchasing the pet
 * @return successful operation
 */
export function placeOrder(body: Types.Order , cancelToken?: CancelToken | undefined): Promise<Types.Order> {
    let url_ = getBaseUrl() + "/store/order";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigPlaceOrder,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            "Content-Type": "application/json",
            "Accept": "application/json"
        },
        cancelToken
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processPlaceOrder(_response);
    });
}

function processPlaceOrder(response: AxiosResponse): Promise<Types.Order> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.Order.fromJS(resultData200);
        return Promise.resolve<Types.Order>(result200);

    } else if (status === 400) {
        const _responseText = response.data;
        return throwException("Invalid Order", status, _responseText, _headers);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.Order>(null as any);
}

/**
 * Find purchase order by ID
 * @param orderId ID of pet that needs to be fetched
 * @return successful operation
 */
export function getOrderById(orderId: number , cancelToken?: CancelToken | undefined): Promise<Types.Order> {
    let url_ = getBaseUrl() + "/store/order/{orderId}";

    if (orderId === undefined || orderId === null)
      throw new Error("The parameter 'orderId' must be defined.");
    url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigGetOrderById,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "application/json"
        },
        cancelToken
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processGetOrderById(_response);
    });
}

function processGetOrderById(response: AxiosResponse): Promise<Types.Order> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.Order.fromJS(resultData200);
        return Promise.resolve<Types.Order>(result200);

    } else if (status === 400) {
        const _responseText = response.data;
        return throwException("Invalid ID supplied", status, _responseText, _headers);

    } else if (status === 404) {
        const _responseText = response.data;
        return throwException("Order not found", status, _responseText, _headers);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.Order>(null as any);
}

/**
 * Delete purchase order by ID
 * @param orderId ID of the order that needs to be deleted
 */
export function deleteOrder(orderId: number , cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/store/order/{orderId}";

    if (orderId === undefined || orderId === null)
      throw new Error("The parameter 'orderId' must be defined.");
    url_ = url_.replace("{orderId}", encodeURIComponent("" + orderId));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigDeleteOrder,
        method: "DELETE",
        url: url_,
        headers: {
        },
        cancelToken
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processDeleteOrder(_response);
    });
}

function processDeleteOrder(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 400) {
        const _responseText = response.data;
        return throwException("Invalid ID supplied", status, _responseText, _headers);

    } else if (status === 404) {
        const _responseText = response.data;
        return throwException("Order not found", status, _responseText, _headers);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}

/**
 * Returns pet inventories by status
 * @return successful operation
 */
export function getInventory(  cancelToken?: CancelToken | undefined): Promise<{ [key: string]: number; }> {
    let url_ = getBaseUrl() + "/store/inventory";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigGetInventory,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "application/json"
        },
        cancelToken
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processGetInventory(_response);
    });
}

function processGetInventory(response: AxiosResponse): Promise<{ [key: string]: number; }> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        if (resultData200) {
            result200 = {} as any;
            for (let key in resultData200) {
                if (resultData200.hasOwnProperty(key))
                    (<any>result200)![key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
            }
        }
        else {
            result200 = <any>null;
        }
        return Promise.resolve<{ [key: string]: number; }>(result200);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<{ [key: string]: number; }>(null as any);
}

/**
 * Creates list of users with given input array
 * @param body List of user object
 * @return successful operation
 */
export function createUsersWithArrayInput(body: Types.User[] , cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/user/createWithArray";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigCreateUsersWithArrayInput,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            "Content-Type": "application/json",
        },
        cancelToken
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processCreateUsersWithArrayInput(_response);
    });
}

function processCreateUsersWithArrayInput(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    {
        const _responseText = response.data;
        return Promise.resolve<void>(null as any);

    }
}

/**
 * Creates list of users with given input array
 * @param body List of user object
 * @return successful operation
 */
export function createUsersWithListInput(body: Types.User[] , cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/user/createWithList";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigCreateUsersWithListInput,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            "Content-Type": "application/json",
        },
        cancelToken
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processCreateUsersWithListInput(_response);
    });
}

function processCreateUsersWithListInput(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    {
        const _responseText = response.data;
        return Promise.resolve<void>(null as any);

    }
}

/**
 * Get user by user name
 * @param username The name that needs to be fetched. Use user1 for testing.
 * @return successful operation
 */
export function getUserByName(username: string , cancelToken?: CancelToken | undefined): Promise<Types.User> {
    let url_ = getBaseUrl() + "/user/{username}";

    if (username === undefined || username === null)
      throw new Error("The parameter 'username' must be defined.");
    url_ = url_.replace("{username}", encodeURIComponent("" + username));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigGetUserByName,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "application/json"
        },
        cancelToken
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processGetUserByName(_response);
    });
}

function processGetUserByName(response: AxiosResponse): Promise<Types.User> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
        result200 = Types.User.fromJS(resultData200);
        return Promise.resolve<Types.User>(result200);

    } else if (status === 400) {
        const _responseText = response.data;
        return throwException("Invalid username supplied", status, _responseText, _headers);

    } else if (status === 404) {
        const _responseText = response.data;
        return throwException("User not found", status, _responseText, _headers);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<Types.User>(null as any);
}

/**
 * Updated user
 * @param username name that need to be updated
 * @param body Updated user object
 */
export function updateUser(username: string, body: Types.User , cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/user/{username}";

    if (username === undefined || username === null)
      throw new Error("The parameter 'username' must be defined.");
    url_ = url_.replace("{username}", encodeURIComponent("" + username));
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigUpdateUser,
        data: content_,
        method: "PUT",
        url: url_,
        headers: {
            "Content-Type": "application/json",
        },
        cancelToken
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processUpdateUser(_response);
    });
}

function processUpdateUser(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 400) {
        const _responseText = response.data;
        return throwException("Invalid user supplied", status, _responseText, _headers);

    } else if (status === 404) {
        const _responseText = response.data;
        return throwException("User not found", status, _responseText, _headers);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}

/**
 * Delete user
 * @param username The name that needs to be deleted
 */
export function deleteUser(username: string , cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/user/{username}";

    if (username === undefined || username === null)
      throw new Error("The parameter 'username' must be defined.");
    url_ = url_.replace("{username}", encodeURIComponent("" + username));
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigDeleteUser,
        method: "DELETE",
        url: url_,
        headers: {
        },
        cancelToken
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processDeleteUser(_response);
    });
}

function processDeleteUser(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 400) {
        const _responseText = response.data;
        return throwException("Invalid username supplied", status, _responseText, _headers);

    } else if (status === 404) {
        const _responseText = response.data;
        return throwException("User not found", status, _responseText, _headers);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<void>(null as any);
}

/**
 * Logs user into the system
 * @param username The user name for login
 * @param password The password for login in clear text
 * @return successful operation
 */
export function loginUser(username: string, password: string , cancelToken?: CancelToken | undefined): Promise<string> {
    let url_ = getBaseUrl() + "/user/login?";
      if (username === undefined || username === null)
        throw new Error("The parameter 'username' must be defined and cannot be null.");
      else
        url_ += "username=" + encodeURIComponent("" + username) + "&";
      if (password === undefined || password === null)
        throw new Error("The parameter 'password' must be defined and cannot be null.");
      else
        url_ += "password=" + encodeURIComponent("" + password) + "&";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigLoginUser,
        method: "GET",
        url: url_,
        headers: {
            "Accept": "application/json"
        },
        cancelToken
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processLoginUser(_response);
    });
}

function processLoginUser(response: AxiosResponse): Promise<string> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    if (status === 200) {
        const _responseText = response.data;
        let result200: any = null;
        let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
    
        return Promise.resolve<string>(result200);

    } else if (status === 400) {
        const _responseText = response.data;
        return throwException("Invalid username/password supplied", status, _responseText, _headers);

    } else if (status !== 200 && status !== 204) {
        const _responseText = response.data;
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
    }
    return Promise.resolve<string>(null as any);
}

/**
 * Logs out current logged in user session
 * @return successful operation
 */
export function logoutUser(  cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/user/logout";
      url_ = url_.replace(/[?&]$/, "");

    let options_: AxiosRequestConfig = {
        ..._requestConfigLogoutUser,
        method: "GET",
        url: url_,
        headers: {
        },
        cancelToken
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processLogoutUser(_response);
    });
}

function processLogoutUser(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    {
        const _responseText = response.data;
        return Promise.resolve<void>(null as any);

    }
}

/**
 * Create user
 * @param body Created user object
 * @return successful operation
 */
export function createUser(body: Types.User , cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = getBaseUrl() + "/user";
      url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_: AxiosRequestConfig = {
        ..._requestConfigCreateUser,
        data: content_,
        method: "POST",
        url: url_,
        headers: {
            "Content-Type": "application/json",
        },
        cancelToken
    };

    return getAxios().request(options_).catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
            return _error.response;
        } else {
            throw _error;
        }
    }).then((_response: AxiosResponse) => {
        return processCreateUser(_response);
    });
}

function processCreateUser(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
        for (let k in response.headers) {
            if (response.headers.hasOwnProperty(k)) {
                _headers[k] = response.headers[k];
            }
        }
    }
    {
        const _responseText = response.data;
        return Promise.resolve<void>(null as any);

    }
}
let _requestConfigUploadFile: Partial<AxiosRequestConfig> | null;
export function getUploadFileRequestConfig() {
  return _requestConfigUploadFile;
}
export function setUploadFileRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigUploadFile = value;
}
export function patchUploadFileRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigUploadFile = patch(_requestConfigUploadFile ?? {});
}

let _requestConfigAddPet: Partial<AxiosRequestConfig> | null;
export function getAddPetRequestConfig() {
  return _requestConfigAddPet;
}
export function setAddPetRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigAddPet = value;
}
export function patchAddPetRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigAddPet = patch(_requestConfigAddPet ?? {});
}

let _requestConfigUpdatePet: Partial<AxiosRequestConfig> | null;
export function getUpdatePetRequestConfig() {
  return _requestConfigUpdatePet;
}
export function setUpdatePetRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigUpdatePet = value;
}
export function patchUpdatePetRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigUpdatePet = patch(_requestConfigUpdatePet ?? {});
}

let _requestConfigFindPetsByStatus: Partial<AxiosRequestConfig> | null;
export function getFindPetsByStatusRequestConfig() {
  return _requestConfigFindPetsByStatus;
}
export function setFindPetsByStatusRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigFindPetsByStatus = value;
}
export function patchFindPetsByStatusRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigFindPetsByStatus = patch(_requestConfigFindPetsByStatus ?? {});
}

let _requestConfigFindPetsByTags: Partial<AxiosRequestConfig> | null;
export function getFindPetsByTagsRequestConfig() {
  return _requestConfigFindPetsByTags;
}
export function setFindPetsByTagsRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigFindPetsByTags = value;
}
export function patchFindPetsByTagsRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigFindPetsByTags = patch(_requestConfigFindPetsByTags ?? {});
}

let _requestConfigGetPetById: Partial<AxiosRequestConfig> | null;
export function getGetPetByIdRequestConfig() {
  return _requestConfigGetPetById;
}
export function setGetPetByIdRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigGetPetById = value;
}
export function patchGetPetByIdRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigGetPetById = patch(_requestConfigGetPetById ?? {});
}

let _requestConfigUpdatePetWithForm: Partial<AxiosRequestConfig> | null;
export function getUpdatePetWithFormRequestConfig() {
  return _requestConfigUpdatePetWithForm;
}
export function setUpdatePetWithFormRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigUpdatePetWithForm = value;
}
export function patchUpdatePetWithFormRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigUpdatePetWithForm = patch(_requestConfigUpdatePetWithForm ?? {});
}

let _requestConfigDeletePet: Partial<AxiosRequestConfig> | null;
export function getDeletePetRequestConfig() {
  return _requestConfigDeletePet;
}
export function setDeletePetRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigDeletePet = value;
}
export function patchDeletePetRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigDeletePet = patch(_requestConfigDeletePet ?? {});
}

let _requestConfigPlaceOrder: Partial<AxiosRequestConfig> | null;
export function getPlaceOrderRequestConfig() {
  return _requestConfigPlaceOrder;
}
export function setPlaceOrderRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigPlaceOrder = value;
}
export function patchPlaceOrderRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigPlaceOrder = patch(_requestConfigPlaceOrder ?? {});
}

let _requestConfigGetOrderById: Partial<AxiosRequestConfig> | null;
export function getGetOrderByIdRequestConfig() {
  return _requestConfigGetOrderById;
}
export function setGetOrderByIdRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigGetOrderById = value;
}
export function patchGetOrderByIdRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigGetOrderById = patch(_requestConfigGetOrderById ?? {});
}

let _requestConfigDeleteOrder: Partial<AxiosRequestConfig> | null;
export function getDeleteOrderRequestConfig() {
  return _requestConfigDeleteOrder;
}
export function setDeleteOrderRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigDeleteOrder = value;
}
export function patchDeleteOrderRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigDeleteOrder = patch(_requestConfigDeleteOrder ?? {});
}

let _requestConfigGetInventory: Partial<AxiosRequestConfig> | null;
export function getGetInventoryRequestConfig() {
  return _requestConfigGetInventory;
}
export function setGetInventoryRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigGetInventory = value;
}
export function patchGetInventoryRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigGetInventory = patch(_requestConfigGetInventory ?? {});
}

let _requestConfigCreateUsersWithArrayInput: Partial<AxiosRequestConfig> | null;
export function getCreateUsersWithArrayInputRequestConfig() {
  return _requestConfigCreateUsersWithArrayInput;
}
export function setCreateUsersWithArrayInputRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigCreateUsersWithArrayInput = value;
}
export function patchCreateUsersWithArrayInputRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigCreateUsersWithArrayInput = patch(_requestConfigCreateUsersWithArrayInput ?? {});
}

let _requestConfigCreateUsersWithListInput: Partial<AxiosRequestConfig> | null;
export function getCreateUsersWithListInputRequestConfig() {
  return _requestConfigCreateUsersWithListInput;
}
export function setCreateUsersWithListInputRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigCreateUsersWithListInput = value;
}
export function patchCreateUsersWithListInputRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigCreateUsersWithListInput = patch(_requestConfigCreateUsersWithListInput ?? {});
}

let _requestConfigGetUserByName: Partial<AxiosRequestConfig> | null;
export function getGetUserByNameRequestConfig() {
  return _requestConfigGetUserByName;
}
export function setGetUserByNameRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigGetUserByName = value;
}
export function patchGetUserByNameRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigGetUserByName = patch(_requestConfigGetUserByName ?? {});
}

let _requestConfigUpdateUser: Partial<AxiosRequestConfig> | null;
export function getUpdateUserRequestConfig() {
  return _requestConfigUpdateUser;
}
export function setUpdateUserRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigUpdateUser = value;
}
export function patchUpdateUserRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigUpdateUser = patch(_requestConfigUpdateUser ?? {});
}

let _requestConfigDeleteUser: Partial<AxiosRequestConfig> | null;
export function getDeleteUserRequestConfig() {
  return _requestConfigDeleteUser;
}
export function setDeleteUserRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigDeleteUser = value;
}
export function patchDeleteUserRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigDeleteUser = patch(_requestConfigDeleteUser ?? {});
}

let _requestConfigLoginUser: Partial<AxiosRequestConfig> | null;
export function getLoginUserRequestConfig() {
  return _requestConfigLoginUser;
}
export function setLoginUserRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigLoginUser = value;
}
export function patchLoginUserRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigLoginUser = patch(_requestConfigLoginUser ?? {});
}

let _requestConfigLogoutUser: Partial<AxiosRequestConfig> | null;
export function getLogoutUserRequestConfig() {
  return _requestConfigLogoutUser;
}
export function setLogoutUserRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigLogoutUser = value;
}
export function patchLogoutUserRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigLogoutUser = patch(_requestConfigLogoutUser ?? {});
}

let _requestConfigCreateUser: Partial<AxiosRequestConfig> | null;
export function getCreateUserRequestConfig() {
  return _requestConfigCreateUser;
}
export function setCreateUserRequestConfig(value: Partial<AxiosRequestConfig>) {
  _requestConfigCreateUser = value;
}
export function patchCreateUserRequestConfig(patch: (value: Partial<AxiosRequestConfig>) => Partial<AxiosRequestConfig>) {
  _requestConfigCreateUser = patch(_requestConfigCreateUser ?? {});
}
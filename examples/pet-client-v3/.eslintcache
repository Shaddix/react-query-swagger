[{"C:\\Work\\react-query-swagger\\examples\\pet-client\\src\\index.tsx":"1","C:\\Work\\react-query-swagger\\examples\\pet-client\\src\\api\\index.ts":"2","C:\\Work\\react-query-swagger\\examples\\pet-client\\src\\api\\fetch-client.ts":"3","C:\\Work\\react-query-swagger\\examples\\pet-client\\src\\App.tsx":"4","C:\\Work\\react-query-swagger\\examples\\pet-client\\src\\api\\axios-client.ts":"5","C:\\Work\\react-query-swagger\\examples\\pet-client\\src\\reportWebVitals.ts":"6","C:\\Work\\react-query-swagger\\examples\\pet-client\\src\\components\\PetsList.tsx":"7"},{"size":848,"mtime":1620046762652,"results":"8","hashOfConfig":"9"},{"size":132,"mtime":1616346421198,"results":"10","hashOfConfig":"9"},{"size":72502,"mtime":1650798557804,"results":"11","hashOfConfig":"9"},{"size":2939,"mtime":1650853853549,"results":"12","hashOfConfig":"9"},{"size":80153,"mtime":1650853546908,"results":"13","hashOfConfig":"9"},{"size":440,"mtime":1616346421199,"results":"14","hashOfConfig":"9"},{"size":443,"mtime":1650852891737,"results":"15","hashOfConfig":"9"},{"filePath":"16","messages":"17","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},"6jvey2",{"filePath":"19","messages":"20","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"18"},{"filePath":"21","messages":"22","errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":1,"fixableWarningCount":0,"source":"23","usedDeprecatedRules":"18"},{"filePath":"24","messages":"25","errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"26","messages":"27","errorCount":1,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":1,"fixableWarningCount":0,"source":"28","usedDeprecatedRules":"18"},{"filePath":"29","messages":"30","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"31","usedDeprecatedRules":"18"},{"filePath":"32","messages":"33","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"34","usedDeprecatedRules":"35"},"C:\\Work\\react-query-swagger\\examples\\pet-client\\src\\index.tsx",[],[],"C:\\Work\\react-query-swagger\\examples\\pet-client\\src\\api\\index.ts",[],"C:\\Work\\react-query-swagger\\examples\\pet-client\\src\\api\\fetch-client.ts",["36","37"],"const resultTypesByQueryKey: Record<\n  string,\n  () => { init(data: any): void }\n> = {};\n\n/* tslint:disable */\n/* eslint-disable */\n//----------------------\n// <auto-generated>\n//     Generated using the NSwag toolchain v13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)\n// </auto-generated>\n//----------------------\n// ReSharper disable InconsistentNaming\n\nexport class Client {\n  private http: {\n    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;\n  };\n  private baseUrl: string;\n  protected jsonParseReviver:\n    | ((key: string, value: any) => any)\n    | undefined = undefined;\n\n  constructor(\n    baseUrl?: string,\n    http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> },\n  ) {\n    this.http = http ? http : <any>window;\n    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '/v2';\n  }\n\n  /**\n   * uploads an image\n   * @param petId ID of pet to update\n   * @param additionalMetadata (optional) Additional data to pass to server\n   * @param file (optional) file to upload\n   * @return successful operation\n   */\n  uploadFile(\n    petId: number,\n    additionalMetadata?: string | null | undefined,\n    file?: FileParameter | null | undefined,\n  ): Promise<ApiResponse> {\n    let url_ = this.baseUrl + '/pet/{petId}/uploadImage';\n    if (petId === undefined || petId === null)\n      throw new Error(\"The parameter 'petId' must be defined.\");\n    url_ = url_.replace('{petId}', encodeURIComponent('' + petId));\n    url_ = url_.replace(/[?&]$/, '');\n\n    const content_ = new FormData();\n    if (additionalMetadata !== null && additionalMetadata !== undefined)\n      content_.append('additionalMetadata', additionalMetadata.toString());\n    if (file !== null && file !== undefined)\n      content_.append(\n        'file',\n        file.data,\n        file.fileName ? file.fileName : 'file',\n      );\n\n    let options_ = <RequestInit>{\n      body: content_,\n      method: 'POST',\n      headers: {\n        Accept: 'application/json',\n      },\n    };\n\n    return this.http.fetch(url_, options_).then((_response: Response) => {\n      return this.processUploadFile(_response);\n    });\n  }\n\n  protected processUploadFile(response: Response): Promise<ApiResponse> {\n    const status = response.status;\n    let _headers: any = {};\n    if (response.headers && response.headers.forEach) {\n      response.headers.forEach((v: any, k: any) => (_headers[k] = v));\n    }\n    if (status === 200) {\n      return response.text().then((_responseText) => {\n        let result200: any = null;\n        let resultData200 =\n          _responseText === ''\n            ? null\n            : JSON.parse(_responseText, this.jsonParseReviver);\n        result200 = ApiResponse.fromJS(resultData200);\n        return result200;\n      });\n    } else if (status !== 200 && status !== 204) {\n      return response.text().then((_responseText) => {\n        return throwException(\n          'An unexpected server error occurred.',\n          status,\n          _responseText,\n          _headers,\n        );\n      });\n    }\n    return Promise.resolve<ApiResponse>(null as any);\n  }\n\n  /**\n   * Add a new pet to the store\n   * @param body Pet object that needs to be added to the store\n   */\n  addPet(body: Pet): Promise<void> {\n    let url_ = this.baseUrl + '/pet';\n    url_ = url_.replace(/[?&]$/, '');\n\n    const content_ = JSON.stringify(body);\n\n    let options_ = <RequestInit>{\n      body: content_,\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    };\n\n    return this.http.fetch(url_, options_).then((_response: Response) => {\n      return this.processAddPet(_response);\n    });\n  }\n\n  protected processAddPet(response: Response): Promise<void> {\n    const status = response.status;\n    let _headers: any = {};\n    if (response.headers && response.headers.forEach) {\n      response.headers.forEach((v: any, k: any) => (_headers[k] = v));\n    }\n    if (status === 405) {\n      return response.text().then((_responseText) => {\n        return throwException('Invalid input', status, _responseText, _headers);\n      });\n    } else if (status !== 200 && status !== 204) {\n      return response.text().then((_responseText) => {\n        return throwException(\n          'An unexpected server error occurred.',\n          status,\n          _responseText,\n          _headers,\n        );\n      });\n    }\n    return Promise.resolve<void>(null as any);\n  }\n\n  /**\n   * Update an existing pet\n   * @param body Pet object that needs to be added to the store\n   */\n  updatePet(body: Pet): Promise<void> {\n    let url_ = this.baseUrl + '/pet';\n    url_ = url_.replace(/[?&]$/, '');\n\n    const content_ = JSON.stringify(body);\n\n    let options_ = <RequestInit>{\n      body: content_,\n      method: 'PUT',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    };\n\n    return this.http.fetch(url_, options_).then((_response: Response) => {\n      return this.processUpdatePet(_response);\n    });\n  }\n\n  protected processUpdatePet(response: Response): Promise<void> {\n    const status = response.status;\n    let _headers: any = {};\n    if (response.headers && response.headers.forEach) {\n      response.headers.forEach((v: any, k: any) => (_headers[k] = v));\n    }\n    if (status === 400) {\n      return response.text().then((_responseText) => {\n        return throwException(\n          'Invalid ID supplied',\n          status,\n          _responseText,\n          _headers,\n        );\n      });\n    } else if (status === 404) {\n      return response.text().then((_responseText) => {\n        return throwException('Pet not found', status, _responseText, _headers);\n      });\n    } else if (status === 405) {\n      return response.text().then((_responseText) => {\n        return throwException(\n          'Validation exception',\n          status,\n          _responseText,\n          _headers,\n        );\n      });\n    } else if (status !== 200 && status !== 204) {\n      return response.text().then((_responseText) => {\n        return throwException(\n          'An unexpected server error occurred.',\n          status,\n          _responseText,\n          _headers,\n        );\n      });\n    }\n    return Promise.resolve<void>(null as any);\n  }\n\n  /**\n   * Finds Pets by status\n   * @param status Status values that need to be considered for filter\n   * @return successful operation\n   */\n  findPetsByStatus(status: Status[]): Promise<Pet[]> {\n    let url_ = this.baseUrl + '/pet/findByStatus?';\n    if (status === undefined || status === null)\n      throw new Error(\n        \"The parameter 'status' must be defined and cannot be null.\",\n      );\n    else\n      status &&\n        status.forEach((item) => {\n          url_ += 'status=' + encodeURIComponent('' + item) + '&';\n        });\n    url_ = url_.replace(/[?&]$/, '');\n\n    let options_ = <RequestInit>{\n      method: 'GET',\n      headers: {\n        Accept: 'application/json',\n      },\n    };\n\n    return this.http.fetch(url_, options_).then((_response: Response) => {\n      return this.processFindPetsByStatus(_response);\n    });\n  }\n\n  protected processFindPetsByStatus(response: Response): Promise<Pet[]> {\n    const status = response.status;\n    let _headers: any = {};\n    if (response.headers && response.headers.forEach) {\n      response.headers.forEach((v: any, k: any) => (_headers[k] = v));\n    }\n    if (status === 200) {\n      return response.text().then((_responseText) => {\n        let result200: any = null;\n        let resultData200 =\n          _responseText === ''\n            ? null\n            : JSON.parse(_responseText, this.jsonParseReviver);\n        if (Array.isArray(resultData200)) {\n          result200 = [] as any;\n          for (let item of resultData200) result200!.push(Pet.fromJS(item));\n        } else {\n          result200 = <any>null;\n        }\n        return result200;\n      });\n    } else if (status === 400) {\n      return response.text().then((_responseText) => {\n        return throwException(\n          'Invalid status value',\n          status,\n          _responseText,\n          _headers,\n        );\n      });\n    } else if (status !== 200 && status !== 204) {\n      return response.text().then((_responseText) => {\n        return throwException(\n          'An unexpected server error occurred.',\n          status,\n          _responseText,\n          _headers,\n        );\n      });\n    }\n    return Promise.resolve<Pet[]>(null as any);\n  }\n\n  /**\n   * Finds Pets by tags\n   * @param tags Tags to filter by\n   * @return successful operation\n   * @deprecated\n   */\n  findPetsByTags(tags: string[]): Promise<Pet[]> {\n    let url_ = this.baseUrl + '/pet/findByTags?';\n    if (tags === undefined || tags === null)\n      throw new Error(\n        \"The parameter 'tags' must be defined and cannot be null.\",\n      );\n    else\n      tags &&\n        tags.forEach((item) => {\n          url_ += 'tags=' + encodeURIComponent('' + item) + '&';\n        });\n    url_ = url_.replace(/[?&]$/, '');\n\n    let options_ = <RequestInit>{\n      method: 'GET',\n      headers: {\n        Accept: 'application/json',\n      },\n    };\n\n    return this.http.fetch(url_, options_).then((_response: Response) => {\n      return this.processFindPetsByTags(_response);\n    });\n  }\n\n  protected processFindPetsByTags(response: Response): Promise<Pet[]> {\n    const status = response.status;\n    let _headers: any = {};\n    if (response.headers && response.headers.forEach) {\n      response.headers.forEach((v: any, k: any) => (_headers[k] = v));\n    }\n    if (status === 200) {\n      return response.text().then((_responseText) => {\n        let result200: any = null;\n        let resultData200 =\n          _responseText === ''\n            ? null\n            : JSON.parse(_responseText, this.jsonParseReviver);\n        if (Array.isArray(resultData200)) {\n          result200 = [] as any;\n          for (let item of resultData200) result200!.push(Pet.fromJS(item));\n        } else {\n          result200 = <any>null;\n        }\n        return result200;\n      });\n    } else if (status === 400) {\n      return response.text().then((_responseText) => {\n        return throwException(\n          'Invalid tag value',\n          status,\n          _responseText,\n          _headers,\n        );\n      });\n    } else if (status !== 200 && status !== 204) {\n      return response.text().then((_responseText) => {\n        return throwException(\n          'An unexpected server error occurred.',\n          status,\n          _responseText,\n          _headers,\n        );\n      });\n    }\n    return Promise.resolve<Pet[]>(null as any);\n  }\n\n  /**\n   * Find pet by ID\n   * @param petId ID of pet to return\n   * @return successful operation\n   */\n  getPetById(petId: number): Promise<Pet> {\n    let url_ = this.baseUrl + '/pet/{petId}';\n    if (petId === undefined || petId === null)\n      throw new Error(\"The parameter 'petId' must be defined.\");\n    url_ = url_.replace('{petId}', encodeURIComponent('' + petId));\n    url_ = url_.replace(/[?&]$/, '');\n\n    let options_ = <RequestInit>{\n      method: 'GET',\n      headers: {\n        Accept: 'application/json',\n      },\n    };\n\n    return this.http.fetch(url_, options_).then((_response: Response) => {\n      return this.processGetPetById(_response);\n    });\n  }\n\n  protected processGetPetById(response: Response): Promise<Pet> {\n    const status = response.status;\n    let _headers: any = {};\n    if (response.headers && response.headers.forEach) {\n      response.headers.forEach((v: any, k: any) => (_headers[k] = v));\n    }\n    if (status === 200) {\n      return response.text().then((_responseText) => {\n        let result200: any = null;\n        let resultData200 =\n          _responseText === ''\n            ? null\n            : JSON.parse(_responseText, this.jsonParseReviver);\n        result200 = Pet.fromJS(resultData200);\n        return result200;\n      });\n    } else if (status === 400) {\n      return response.text().then((_responseText) => {\n        return throwException(\n          'Invalid ID supplied',\n          status,\n          _responseText,\n          _headers,\n        );\n      });\n    } else if (status === 404) {\n      return response.text().then((_responseText) => {\n        return throwException('Pet not found', status, _responseText, _headers);\n      });\n    } else if (status !== 200 && status !== 204) {\n      return response.text().then((_responseText) => {\n        return throwException(\n          'An unexpected server error occurred.',\n          status,\n          _responseText,\n          _headers,\n        );\n      });\n    }\n    return Promise.resolve<Pet>(null as any);\n  }\n\n  /**\n   * Updates a pet in the store with form data\n   * @param petId ID of pet that needs to be updated\n   * @param name (optional) Updated name of the pet\n   * @param status (optional) Updated status of the pet\n   */\n  updatePetWithForm(\n    petId: number,\n    name?: string | null | undefined,\n    status?: string | null | undefined,\n  ): Promise<void> {\n    let url_ = this.baseUrl + '/pet/{petId}';\n    if (petId === undefined || petId === null)\n      throw new Error(\"The parameter 'petId' must be defined.\");\n    url_ = url_.replace('{petId}', encodeURIComponent('' + petId));\n    url_ = url_.replace(/[?&]$/, '');\n\n    let content_ = '';\n    if (name !== undefined)\n      content_ +=\n        encodeURIComponent('name') + '=' + encodeURIComponent('' + name) + '&';\n    if (status !== undefined)\n      content_ +=\n        encodeURIComponent('status') +\n        '=' +\n        encodeURIComponent('' + status) +\n        '&';\n    content_ = content_.replace(/&$/, '');\n\n    let options_ = <RequestInit>{\n      body: content_,\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n      },\n    };\n\n    return this.http.fetch(url_, options_).then((_response: Response) => {\n      return this.processUpdatePetWithForm(_response);\n    });\n  }\n\n  protected processUpdatePetWithForm(response: Response): Promise<void> {\n    const status = response.status;\n    let _headers: any = {};\n    if (response.headers && response.headers.forEach) {\n      response.headers.forEach((v: any, k: any) => (_headers[k] = v));\n    }\n    if (status === 405) {\n      return response.text().then((_responseText) => {\n        return throwException('Invalid input', status, _responseText, _headers);\n      });\n    } else if (status !== 200 && status !== 204) {\n      return response.text().then((_responseText) => {\n        return throwException(\n          'An unexpected server error occurred.',\n          status,\n          _responseText,\n          _headers,\n        );\n      });\n    }\n    return Promise.resolve<void>(null as any);\n  }\n\n  /**\n   * Deletes a pet\n   * @param petId Pet id to delete\n   * @param api_key (optional)\n   */\n  deletePet(petId: number, api_key?: string | null | undefined): Promise<void> {\n    let url_ = this.baseUrl + '/pet/{petId}';\n    if (petId === undefined || petId === null)\n      throw new Error(\"The parameter 'petId' must be defined.\");\n    url_ = url_.replace('{petId}', encodeURIComponent('' + petId));\n    url_ = url_.replace(/[?&]$/, '');\n\n    let options_ = <RequestInit>{\n      method: 'DELETE',\n      headers: {\n        api_key: api_key !== undefined && api_key !== null ? '' + api_key : '',\n      },\n    };\n\n    return this.http.fetch(url_, options_).then((_response: Response) => {\n      return this.processDeletePet(_response);\n    });\n  }\n\n  protected processDeletePet(response: Response): Promise<void> {\n    const status = response.status;\n    let _headers: any = {};\n    if (response.headers && response.headers.forEach) {\n      response.headers.forEach((v: any, k: any) => (_headers[k] = v));\n    }\n    if (status === 400) {\n      return response.text().then((_responseText) => {\n        return throwException(\n          'Invalid ID supplied',\n          status,\n          _responseText,\n          _headers,\n        );\n      });\n    } else if (status === 404) {\n      return response.text().then((_responseText) => {\n        return throwException('Pet not found', status, _responseText, _headers);\n      });\n    } else if (status !== 200 && status !== 204) {\n      return response.text().then((_responseText) => {\n        return throwException(\n          'An unexpected server error occurred.',\n          status,\n          _responseText,\n          _headers,\n        );\n      });\n    }\n    return Promise.resolve<void>(null as any);\n  }\n\n  /**\n   * Place an order for a pet\n   * @param body order placed for purchasing the pet\n   * @return successful operation\n   */\n  placeOrder(body: Order): Promise<Order> {\n    let url_ = this.baseUrl + '/store/order';\n    url_ = url_.replace(/[?&]$/, '');\n\n    const content_ = JSON.stringify(body);\n\n    let options_ = <RequestInit>{\n      body: content_,\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        Accept: 'application/json',\n      },\n    };\n\n    return this.http.fetch(url_, options_).then((_response: Response) => {\n      return this.processPlaceOrder(_response);\n    });\n  }\n\n  protected processPlaceOrder(response: Response): Promise<Order> {\n    const status = response.status;\n    let _headers: any = {};\n    if (response.headers && response.headers.forEach) {\n      response.headers.forEach((v: any, k: any) => (_headers[k] = v));\n    }\n    if (status === 200) {\n      return response.text().then((_responseText) => {\n        let result200: any = null;\n        let resultData200 =\n          _responseText === ''\n            ? null\n            : JSON.parse(_responseText, this.jsonParseReviver);\n        result200 = Order.fromJS(resultData200);\n        return result200;\n      });\n    } else if (status === 400) {\n      return response.text().then((_responseText) => {\n        return throwException('Invalid Order', status, _responseText, _headers);\n      });\n    } else if (status !== 200 && status !== 204) {\n      return response.text().then((_responseText) => {\n        return throwException(\n          'An unexpected server error occurred.',\n          status,\n          _responseText,\n          _headers,\n        );\n      });\n    }\n    return Promise.resolve<Order>(null as any);\n  }\n\n  /**\n   * Find purchase order by ID\n   * @param orderId ID of pet that needs to be fetched\n   * @return successful operation\n   */\n  getOrderById(orderId: number): Promise<Order> {\n    let url_ = this.baseUrl + '/store/order/{orderId}';\n    if (orderId === undefined || orderId === null)\n      throw new Error(\"The parameter 'orderId' must be defined.\");\n    url_ = url_.replace('{orderId}', encodeURIComponent('' + orderId));\n    url_ = url_.replace(/[?&]$/, '');\n\n    let options_ = <RequestInit>{\n      method: 'GET',\n      headers: {\n        Accept: 'application/json',\n      },\n    };\n\n    return this.http.fetch(url_, options_).then((_response: Response) => {\n      return this.processGetOrderById(_response);\n    });\n  }\n\n  protected processGetOrderById(response: Response): Promise<Order> {\n    const status = response.status;\n    let _headers: any = {};\n    if (response.headers && response.headers.forEach) {\n      response.headers.forEach((v: any, k: any) => (_headers[k] = v));\n    }\n    if (status === 200) {\n      return response.text().then((_responseText) => {\n        let result200: any = null;\n        let resultData200 =\n          _responseText === ''\n            ? null\n            : JSON.parse(_responseText, this.jsonParseReviver);\n        result200 = Order.fromJS(resultData200);\n        return result200;\n      });\n    } else if (status === 400) {\n      return response.text().then((_responseText) => {\n        return throwException(\n          'Invalid ID supplied',\n          status,\n          _responseText,\n          _headers,\n        );\n      });\n    } else if (status === 404) {\n      return response.text().then((_responseText) => {\n        return throwException(\n          'Order not found',\n          status,\n          _responseText,\n          _headers,\n        );\n      });\n    } else if (status !== 200 && status !== 204) {\n      return response.text().then((_responseText) => {\n        return throwException(\n          'An unexpected server error occurred.',\n          status,\n          _responseText,\n          _headers,\n        );\n      });\n    }\n    return Promise.resolve<Order>(null as any);\n  }\n\n  /**\n   * Delete purchase order by ID\n   * @param orderId ID of the order that needs to be deleted\n   */\n  deleteOrder(orderId: number): Promise<void> {\n    let url_ = this.baseUrl + '/store/order/{orderId}';\n    if (orderId === undefined || orderId === null)\n      throw new Error(\"The parameter 'orderId' must be defined.\");\n    url_ = url_.replace('{orderId}', encodeURIComponent('' + orderId));\n    url_ = url_.replace(/[?&]$/, '');\n\n    let options_ = <RequestInit>{\n      method: 'DELETE',\n      headers: {},\n    };\n\n    return this.http.fetch(url_, options_).then((_response: Response) => {\n      return this.processDeleteOrder(_response);\n    });\n  }\n\n  protected processDeleteOrder(response: Response): Promise<void> {\n    const status = response.status;\n    let _headers: any = {};\n    if (response.headers && response.headers.forEach) {\n      response.headers.forEach((v: any, k: any) => (_headers[k] = v));\n    }\n    if (status === 400) {\n      return response.text().then((_responseText) => {\n        return throwException(\n          'Invalid ID supplied',\n          status,\n          _responseText,\n          _headers,\n        );\n      });\n    } else if (status === 404) {\n      return response.text().then((_responseText) => {\n        return throwException(\n          'Order not found',\n          status,\n          _responseText,\n          _headers,\n        );\n      });\n    } else if (status !== 200 && status !== 204) {\n      return response.text().then((_responseText) => {\n        return throwException(\n          'An unexpected server error occurred.',\n          status,\n          _responseText,\n          _headers,\n        );\n      });\n    }\n    return Promise.resolve<void>(null as any);\n  }\n\n  /**\n   * Returns pet inventories by status\n   * @return successful operation\n   */\n  getInventory(): Promise<{ [key: string]: number }> {\n    let url_ = this.baseUrl + '/store/inventory';\n    url_ = url_.replace(/[?&]$/, '');\n\n    let options_ = <RequestInit>{\n      method: 'GET',\n      headers: {\n        Accept: 'application/json',\n      },\n    };\n\n    return this.http.fetch(url_, options_).then((_response: Response) => {\n      return this.processGetInventory(_response);\n    });\n  }\n\n  protected processGetInventory(\n    response: Response,\n  ): Promise<{ [key: string]: number }> {\n    const status = response.status;\n    let _headers: any = {};\n    if (response.headers && response.headers.forEach) {\n      response.headers.forEach((v: any, k: any) => (_headers[k] = v));\n    }\n    if (status === 200) {\n      return response.text().then((_responseText) => {\n        let result200: any = null;\n        let resultData200 =\n          _responseText === ''\n            ? null\n            : JSON.parse(_responseText, this.jsonParseReviver);\n        if (resultData200) {\n          result200 = {} as any;\n          for (let key in resultData200) {\n            if (resultData200.hasOwnProperty(key))\n              (<any>result200)![key] =\n                resultData200[key] !== undefined\n                  ? resultData200[key]\n                  : <any>null;\n          }\n        } else {\n          result200 = <any>null;\n        }\n        return result200;\n      });\n    } else if (status !== 200 && status !== 204) {\n      return response.text().then((_responseText) => {\n        return throwException(\n          'An unexpected server error occurred.',\n          status,\n          _responseText,\n          _headers,\n        );\n      });\n    }\n    return Promise.resolve<{ [key: string]: number }>(null as any);\n  }\n\n  /**\n   * Creates list of users with given input array\n   * @param body List of user object\n   * @return successful operation\n   */\n  createUsersWithArrayInput(body: User[]): Promise<void> {\n    let url_ = this.baseUrl + '/user/createWithArray';\n    url_ = url_.replace(/[?&]$/, '');\n\n    const content_ = JSON.stringify(body);\n\n    let options_ = <RequestInit>{\n      body: content_,\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    };\n\n    return this.http.fetch(url_, options_).then((_response: Response) => {\n      return this.processCreateUsersWithArrayInput(_response);\n    });\n  }\n\n  protected processCreateUsersWithArrayInput(\n    response: Response,\n  ): Promise<void> {\n    const status = response.status;\n    let _headers: any = {};\n    if (response.headers && response.headers.forEach) {\n      response.headers.forEach((v: any, k: any) => (_headers[k] = v));\n    }\n    {\n      return response.text().then((_responseText) => {\n        return;\n      });\n    }\n  }\n\n  /**\n   * Creates list of users with given input array\n   * @param body List of user object\n   * @return successful operation\n   */\n  createUsersWithListInput(body: User[]): Promise<void> {\n    let url_ = this.baseUrl + '/user/createWithList';\n    url_ = url_.replace(/[?&]$/, '');\n\n    const content_ = JSON.stringify(body);\n\n    let options_ = <RequestInit>{\n      body: content_,\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    };\n\n    return this.http.fetch(url_, options_).then((_response: Response) => {\n      return this.processCreateUsersWithListInput(_response);\n    });\n  }\n\n  protected processCreateUsersWithListInput(response: Response): Promise<void> {\n    const status = response.status;\n    let _headers: any = {};\n    if (response.headers && response.headers.forEach) {\n      response.headers.forEach((v: any, k: any) => (_headers[k] = v));\n    }\n    {\n      return response.text().then((_responseText) => {\n        return;\n      });\n    }\n  }\n\n  /**\n   * Get user by user name\n   * @param username The name that needs to be fetched. Use user1 for testing.\n   * @return successful operation\n   */\n  getUserByName(username: string): Promise<User> {\n    let url_ = this.baseUrl + '/user/{username}';\n    if (username === undefined || username === null)\n      throw new Error(\"The parameter 'username' must be defined.\");\n    url_ = url_.replace('{username}', encodeURIComponent('' + username));\n    url_ = url_.replace(/[?&]$/, '');\n\n    let options_ = <RequestInit>{\n      method: 'GET',\n      headers: {\n        Accept: 'application/json',\n      },\n    };\n\n    return this.http.fetch(url_, options_).then((_response: Response) => {\n      return this.processGetUserByName(_response);\n    });\n  }\n\n  protected processGetUserByName(response: Response): Promise<User> {\n    const status = response.status;\n    let _headers: any = {};\n    if (response.headers && response.headers.forEach) {\n      response.headers.forEach((v: any, k: any) => (_headers[k] = v));\n    }\n    if (status === 200) {\n      return response.text().then((_responseText) => {\n        let result200: any = null;\n        let resultData200 =\n          _responseText === ''\n            ? null\n            : JSON.parse(_responseText, this.jsonParseReviver);\n        result200 = User.fromJS(resultData200);\n        return result200;\n      });\n    } else if (status === 400) {\n      return response.text().then((_responseText) => {\n        return throwException(\n          'Invalid username supplied',\n          status,\n          _responseText,\n          _headers,\n        );\n      });\n    } else if (status === 404) {\n      return response.text().then((_responseText) => {\n        return throwException(\n          'User not found',\n          status,\n          _responseText,\n          _headers,\n        );\n      });\n    } else if (status !== 200 && status !== 204) {\n      return response.text().then((_responseText) => {\n        return throwException(\n          'An unexpected server error occurred.',\n          status,\n          _responseText,\n          _headers,\n        );\n      });\n    }\n    return Promise.resolve<User>(null as any);\n  }\n\n  /**\n   * Updated user\n   * @param username name that need to be updated\n   * @param body Updated user object\n   */\n  updateUser(username: string, body: User): Promise<void> {\n    let url_ = this.baseUrl + '/user/{username}';\n    if (username === undefined || username === null)\n      throw new Error(\"The parameter 'username' must be defined.\");\n    url_ = url_.replace('{username}', encodeURIComponent('' + username));\n    url_ = url_.replace(/[?&]$/, '');\n\n    const content_ = JSON.stringify(body);\n\n    let options_ = <RequestInit>{\n      body: content_,\n      method: 'PUT',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    };\n\n    return this.http.fetch(url_, options_).then((_response: Response) => {\n      return this.processUpdateUser(_response);\n    });\n  }\n\n  protected processUpdateUser(response: Response): Promise<void> {\n    const status = response.status;\n    let _headers: any = {};\n    if (response.headers && response.headers.forEach) {\n      response.headers.forEach((v: any, k: any) => (_headers[k] = v));\n    }\n    if (status === 400) {\n      return response.text().then((_responseText) => {\n        return throwException(\n          'Invalid user supplied',\n          status,\n          _responseText,\n          _headers,\n        );\n      });\n    } else if (status === 404) {\n      return response.text().then((_responseText) => {\n        return throwException(\n          'User not found',\n          status,\n          _responseText,\n          _headers,\n        );\n      });\n    } else if (status !== 200 && status !== 204) {\n      return response.text().then((_responseText) => {\n        return throwException(\n          'An unexpected server error occurred.',\n          status,\n          _responseText,\n          _headers,\n        );\n      });\n    }\n    return Promise.resolve<void>(null as any);\n  }\n\n  /**\n   * Delete user\n   * @param username The name that needs to be deleted\n   */\n  deleteUser(username: string): Promise<void> {\n    let url_ = this.baseUrl + '/user/{username}';\n    if (username === undefined || username === null)\n      throw new Error(\"The parameter 'username' must be defined.\");\n    url_ = url_.replace('{username}', encodeURIComponent('' + username));\n    url_ = url_.replace(/[?&]$/, '');\n\n    let options_ = <RequestInit>{\n      method: 'DELETE',\n      headers: {},\n    };\n\n    return this.http.fetch(url_, options_).then((_response: Response) => {\n      return this.processDeleteUser(_response);\n    });\n  }\n\n  protected processDeleteUser(response: Response): Promise<void> {\n    const status = response.status;\n    let _headers: any = {};\n    if (response.headers && response.headers.forEach) {\n      response.headers.forEach((v: any, k: any) => (_headers[k] = v));\n    }\n    if (status === 400) {\n      return response.text().then((_responseText) => {\n        return throwException(\n          'Invalid username supplied',\n          status,\n          _responseText,\n          _headers,\n        );\n      });\n    } else if (status === 404) {\n      return response.text().then((_responseText) => {\n        return throwException(\n          'User not found',\n          status,\n          _responseText,\n          _headers,\n        );\n      });\n    } else if (status !== 200 && status !== 204) {\n      return response.text().then((_responseText) => {\n        return throwException(\n          'An unexpected server error occurred.',\n          status,\n          _responseText,\n          _headers,\n        );\n      });\n    }\n    return Promise.resolve<void>(null as any);\n  }\n\n  /**\n   * Logs user into the system\n   * @param username The user name for login\n   * @param password The password for login in clear text\n   * @return successful operation\n   */\n  loginUser(username: string, password: string): Promise<string> {\n    let url_ = this.baseUrl + '/user/login?';\n    if (username === undefined || username === null)\n      throw new Error(\n        \"The parameter 'username' must be defined and cannot be null.\",\n      );\n    else url_ += 'username=' + encodeURIComponent('' + username) + '&';\n    if (password === undefined || password === null)\n      throw new Error(\n        \"The parameter 'password' must be defined and cannot be null.\",\n      );\n    else url_ += 'password=' + encodeURIComponent('' + password) + '&';\n    url_ = url_.replace(/[?&]$/, '');\n\n    let options_ = <RequestInit>{\n      method: 'GET',\n      headers: {\n        Accept: 'application/json',\n      },\n    };\n\n    return this.http.fetch(url_, options_).then((_response: Response) => {\n      return this.processLoginUser(_response);\n    });\n  }\n\n  protected processLoginUser(response: Response): Promise<string> {\n    const status = response.status;\n    let _headers: any = {};\n    if (response.headers && response.headers.forEach) {\n      response.headers.forEach((v: any, k: any) => (_headers[k] = v));\n    }\n    if (status === 200) {\n      return response.text().then((_responseText) => {\n        let result200: any = null;\n        let resultData200 =\n          _responseText === ''\n            ? null\n            : JSON.parse(_responseText, this.jsonParseReviver);\n        result200 = resultData200 !== undefined ? resultData200 : <any>null;\n\n        return result200;\n      });\n    } else if (status === 400) {\n      return response.text().then((_responseText) => {\n        return throwException(\n          'Invalid username/password supplied',\n          status,\n          _responseText,\n          _headers,\n        );\n      });\n    } else if (status !== 200 && status !== 204) {\n      return response.text().then((_responseText) => {\n        return throwException(\n          'An unexpected server error occurred.',\n          status,\n          _responseText,\n          _headers,\n        );\n      });\n    }\n    return Promise.resolve<string>(null as any);\n  }\n\n  /**\n   * Logs out current logged in user session\n   * @return successful operation\n   */\n  logoutUser(): Promise<void> {\n    let url_ = this.baseUrl + '/user/logout';\n    url_ = url_.replace(/[?&]$/, '');\n\n    let options_ = <RequestInit>{\n      method: 'GET',\n      headers: {},\n    };\n\n    return this.http.fetch(url_, options_).then((_response: Response) => {\n      return this.processLogoutUser(_response);\n    });\n  }\n\n  protected processLogoutUser(response: Response): Promise<void> {\n    const status = response.status;\n    let _headers: any = {};\n    if (response.headers && response.headers.forEach) {\n      response.headers.forEach((v: any, k: any) => (_headers[k] = v));\n    }\n    {\n      return response.text().then((_responseText) => {\n        return;\n      });\n    }\n  }\n\n  /**\n   * Create user\n   * @param body Created user object\n   * @return successful operation\n   */\n  createUser(body: User): Promise<void> {\n    let url_ = this.baseUrl + '/user';\n    url_ = url_.replace(/[?&]$/, '');\n\n    const content_ = JSON.stringify(body);\n\n    let options_ = <RequestInit>{\n      body: content_,\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n    };\n\n    return this.http.fetch(url_, options_).then((_response: Response) => {\n      return this.processCreateUser(_response);\n    });\n  }\n\n  protected processCreateUser(response: Response): Promise<void> {\n    const status = response.status;\n    let _headers: any = {};\n    if (response.headers && response.headers.forEach) {\n      response.headers.forEach((v: any, k: any) => (_headers[k] = v));\n    }\n    {\n      return response.text().then((_responseText) => {\n        return;\n      });\n    }\n  }\n}\ntype FindPetsByStatusQueryParameters = {\n  status: Status[];\n};\n\ntype FindPetsByTagsQueryParameters = {\n  tags: string[];\n};\n\ntype GetPetByIdQueryParameters = {\n  petId: number;\n};\n\ntype GetOrderByIdQueryParameters = {\n  orderId: number;\n};\n\ntype GetUserByNameQueryParameters = {\n  username: string;\n};\n\ntype LoginUserQueryParameters = {\n  username: string;\n  password: string;\n};\n\nexport class Query {\n  get baseUrl() {\n    return getBaseUrl() ?? '' + '/v2';\n  }\n\n  static get Client() {\n    return createClient(Client);\n  }\n\n  static get Url() {\n    return new Query();\n  }\n\n  findPetsByStatus(status: Status[]): string {\n    let url_ = this.baseUrl + '/pet/findByStatus?';\n    if (status === undefined || status === null)\n      throw new Error(\n        \"The parameter 'status' must be defined and cannot be null.\",\n      );\n    else\n      status &&\n        status.forEach((item) => {\n          url_ += 'status=' + encodeURIComponent('' + item) + '&';\n        });\n    url_ = url_.replace(/[?&]$/, '');\n    return url_;\n  }\n\n  static findPetsByStatusDefaultOptions?: UseQueryOptions<\n    Pet[],\n    unknown,\n    Pet[]\n  > = {};\n  public static findPetsByStatusQueryKey(status: Status[]): QueryKey;\n  public static findPetsByStatusQueryKey(...params: any[]): QueryKey {\n    if (params.length === 1 && isParameterObject(params[0])) {\n      const { status } = params[0] as FindPetsByStatusQueryParameters;\n\n      return removeUndefinedFromArrayTail([\n        'Client',\n        'findPetsByStatus',\n        status as any,\n      ]);\n    } else {\n      return removeUndefinedFromArrayTail([\n        'Client',\n        'findPetsByStatus',\n        ...params,\n      ]);\n    }\n  }\n\n  private static findPetsByStatus(context: QueryFunctionContext) {\n    return Query.Client.findPetsByStatus(context.queryKey[2] as Status[]);\n  }\n\n  static useFindPetsByStatusQuery<TSelectData = Pet[], TError = unknown>(\n    dto: FindPetsByStatusQueryParameters,\n    options?: UseQueryOptions<Pet[], TError, TSelectData>,\n  ): UseQueryResult<TSelectData, TError>;\n  /**\n   * Finds Pets by status\n   * @param status Status values that need to be considered for filter\n   * @return successful operation\n   */\n  static useFindPetsByStatusQuery<TSelectData = Pet[], TError = unknown>(\n    status: Status[],\n    options?: UseQueryOptions<Pet[], TError, TSelectData>,\n  ): UseQueryResult<TSelectData, TError>;\n  static useFindPetsByStatusQuery<TSelectData = Pet[], TError = unknown>(\n    ...params: any[]\n  ): UseQueryResult<TSelectData, TError> {\n    let options:\n      | UseQueryOptions<Pet[], TError, TSelectData>\n      | undefined = undefined;\n    let status: any = undefined;\n\n    if (params.length > 0) {\n      if (isParameterObject(params[0])) {\n        ({ status } = params[0] as FindPetsByStatusQueryParameters);\n        options = params[1];\n      } else {\n        [status, options] = params;\n      }\n    }\n\n    return useQuery<Pet[], TError, TSelectData>({\n      queryFn: Query.findPetsByStatus,\n      queryKey: Query.findPetsByStatusQueryKey(status),\n      ...((Query.findPetsByStatusDefaultOptions as unknown) as UseQueryOptions<\n        Pet[],\n        TError,\n        TSelectData\n      >),\n      ...options,\n    });\n  }\n  /**\n   * Finds Pets by status\n   * @param status Status values that need to be considered for filter\n   * @return successful operation\n   */\n  static setFindPetsByStatusData(\n    queryClient: QueryClient,\n    updater: (data: Pet[] | undefined) => Pet[],\n    status: Status[],\n  ) {\n    queryClient.setQueryData(Query.findPetsByStatusQueryKey(status), updater);\n  }\n\n  /**\n   * Finds Pets by status\n   * @param status Status values that need to be considered for filter\n   * @return successful operation\n   */\n  static setFindPetsByStatusDataByQueryId(\n    queryClient: QueryClient,\n    queryKey: QueryKey,\n    updater: (data: Pet[] | undefined) => Pet[],\n  ) {\n    queryClient.setQueryData(queryKey, updater);\n  }\n\n  findPetsByTags(tags: string[]): string {\n    let url_ = this.baseUrl + '/pet/findByTags?';\n    if (tags === undefined || tags === null)\n      throw new Error(\n        \"The parameter 'tags' must be defined and cannot be null.\",\n      );\n    else\n      tags &&\n        tags.forEach((item) => {\n          url_ += 'tags=' + encodeURIComponent('' + item) + '&';\n        });\n    url_ = url_.replace(/[?&]$/, '');\n    return url_;\n  }\n\n  static findPetsByTagsDefaultOptions?: UseQueryOptions<\n    Pet[],\n    unknown,\n    Pet[]\n  > = {};\n  public static findPetsByTagsQueryKey(tags: string[]): QueryKey;\n  public static findPetsByTagsQueryKey(...params: any[]): QueryKey {\n    if (params.length === 1 && isParameterObject(params[0])) {\n      const { tags } = params[0] as FindPetsByTagsQueryParameters;\n\n      return removeUndefinedFromArrayTail([\n        'Client',\n        'findPetsByTags',\n        tags as any,\n      ]);\n    } else {\n      return removeUndefinedFromArrayTail([\n        'Client',\n        'findPetsByTags',\n        ...params,\n      ]);\n    }\n  }\n\n  private static findPetsByTags(context: QueryFunctionContext) {\n    return Query.Client.findPetsByTags(context.queryKey[2] as string[]);\n  }\n\n  static useFindPetsByTagsQuery<TSelectData = Pet[], TError = unknown>(\n    dto: FindPetsByTagsQueryParameters,\n    options?: UseQueryOptions<Pet[], TError, TSelectData>,\n  ): UseQueryResult<TSelectData, TError>;\n  /**\n   * Finds Pets by tags\n   * @param tags Tags to filter by\n   * @return successful operation\n   * @deprecated\n   */\n  static useFindPetsByTagsQuery<TSelectData = Pet[], TError = unknown>(\n    tags: string[],\n    options?: UseQueryOptions<Pet[], TError, TSelectData>,\n  ): UseQueryResult<TSelectData, TError>;\n  static useFindPetsByTagsQuery<TSelectData = Pet[], TError = unknown>(\n    ...params: any[]\n  ): UseQueryResult<TSelectData, TError> {\n    let options:\n      | UseQueryOptions<Pet[], TError, TSelectData>\n      | undefined = undefined;\n    let tags: any = undefined;\n\n    if (params.length > 0) {\n      if (isParameterObject(params[0])) {\n        ({ tags } = params[0] as FindPetsByTagsQueryParameters);\n        options = params[1];\n      } else {\n        [tags, options] = params;\n      }\n    }\n\n    return useQuery<Pet[], TError, TSelectData>({\n      queryFn: Query.findPetsByTags,\n      queryKey: Query.findPetsByTagsQueryKey(tags),\n      ...((Query.findPetsByTagsDefaultOptions as unknown) as UseQueryOptions<\n        Pet[],\n        TError,\n        TSelectData\n      >),\n      ...options,\n    });\n  }\n  /**\n   * Finds Pets by tags\n   * @param tags Tags to filter by\n   * @return successful operation\n   * @deprecated\n   */\n  static setFindPetsByTagsData(\n    queryClient: QueryClient,\n    updater: (data: Pet[] | undefined) => Pet[],\n    tags: string[],\n  ) {\n    queryClient.setQueryData(Query.findPetsByTagsQueryKey(tags), updater);\n  }\n\n  /**\n   * Finds Pets by tags\n   * @param tags Tags to filter by\n   * @return successful operation\n   * @deprecated\n   */\n  static setFindPetsByTagsDataByQueryId(\n    queryClient: QueryClient,\n    queryKey: QueryKey,\n    updater: (data: Pet[] | undefined) => Pet[],\n  ) {\n    queryClient.setQueryData(queryKey, updater);\n  }\n\n  getPetById(petId: number): string {\n    let url_ = this.baseUrl + '/pet/{petId}';\n    if (petId === undefined || petId === null)\n      throw new Error(\"The parameter 'petId' must be defined.\");\n    url_ = url_.replace('{petId}', encodeURIComponent('' + petId));\n    url_ = url_.replace(/[?&]$/, '');\n    return url_;\n  }\n\n  static getPetByIdDefaultOptions?: UseQueryOptions<Pet, unknown, Pet> = {};\n  public static getPetByIdQueryKey(petId: number): QueryKey;\n  public static getPetByIdQueryKey(...params: any[]): QueryKey {\n    if (params.length === 1 && isParameterObject(params[0])) {\n      const { petId } = params[0] as GetPetByIdQueryParameters;\n\n      return removeUndefinedFromArrayTail([\n        'Client',\n        'getPetById',\n        petId as any,\n      ]);\n    } else {\n      return removeUndefinedFromArrayTail(['Client', 'getPetById', ...params]);\n    }\n  }\n\n  private static getPetById(context: QueryFunctionContext) {\n    return Query.Client.getPetById(context.queryKey[2] as number);\n  }\n\n  static useGetPetByIdQuery<TSelectData = Pet, TError = unknown>(\n    dto: GetPetByIdQueryParameters,\n    options?: UseQueryOptions<Pet, TError, TSelectData>,\n  ): UseQueryResult<TSelectData, TError>;\n  /**\n   * Find pet by ID\n   * @param petId ID of pet to return\n   * @return successful operation\n   */\n  static useGetPetByIdQuery<TSelectData = Pet, TError = unknown>(\n    petId: number,\n    options?: UseQueryOptions<Pet, TError, TSelectData>,\n  ): UseQueryResult<TSelectData, TError>;\n  static useGetPetByIdQuery<TSelectData = Pet, TError = unknown>(\n    ...params: any[]\n  ): UseQueryResult<TSelectData, TError> {\n    let options:\n      | UseQueryOptions<Pet, TError, TSelectData>\n      | undefined = undefined;\n    let petId: any = undefined;\n\n    if (params.length > 0) {\n      if (isParameterObject(params[0])) {\n        ({ petId } = params[0] as GetPetByIdQueryParameters);\n        options = params[1];\n      } else {\n        [petId, options] = params;\n      }\n    }\n\n    return useQuery<Pet, TError, TSelectData>({\n      queryFn: Query.getPetById,\n      queryKey: Query.getPetByIdQueryKey(petId),\n      ...((Query.getPetByIdDefaultOptions as unknown) as UseQueryOptions<\n        Pet,\n        TError,\n        TSelectData\n      >),\n      ...options,\n    });\n  }\n  /**\n   * Find pet by ID\n   * @param petId ID of pet to return\n   * @return successful operation\n   */\n  static setGetPetByIdData(\n    queryClient: QueryClient,\n    updater: (data: Pet | undefined) => Pet,\n    petId: number,\n  ) {\n    queryClient.setQueryData(Query.getPetByIdQueryKey(petId), updater);\n  }\n\n  /**\n   * Find pet by ID\n   * @param petId ID of pet to return\n   * @return successful operation\n   */\n  static setGetPetByIdDataByQueryId(\n    queryClient: QueryClient,\n    queryKey: QueryKey,\n    updater: (data: Pet | undefined) => Pet,\n  ) {\n    queryClient.setQueryData(queryKey, updater);\n  }\n\n  getOrderById(orderId: number): string {\n    let url_ = this.baseUrl + '/store/order/{orderId}';\n    if (orderId === undefined || orderId === null)\n      throw new Error(\"The parameter 'orderId' must be defined.\");\n    url_ = url_.replace('{orderId}', encodeURIComponent('' + orderId));\n    url_ = url_.replace(/[?&]$/, '');\n    return url_;\n  }\n\n  static getOrderByIdDefaultOptions?: UseQueryOptions<\n    Order,\n    unknown,\n    Order\n  > = {};\n  public static getOrderByIdQueryKey(orderId: number): QueryKey;\n  public static getOrderByIdQueryKey(...params: any[]): QueryKey {\n    if (params.length === 1 && isParameterObject(params[0])) {\n      const { orderId } = params[0] as GetOrderByIdQueryParameters;\n\n      return removeUndefinedFromArrayTail([\n        'Client',\n        'getOrderById',\n        orderId as any,\n      ]);\n    } else {\n      return removeUndefinedFromArrayTail([\n        'Client',\n        'getOrderById',\n        ...params,\n      ]);\n    }\n  }\n\n  private static getOrderById(context: QueryFunctionContext) {\n    return Query.Client.getOrderById(context.queryKey[2] as number);\n  }\n\n  static useGetOrderByIdQuery<TSelectData = Order, TError = unknown>(\n    dto: GetOrderByIdQueryParameters,\n    options?: UseQueryOptions<Order, TError, TSelectData>,\n  ): UseQueryResult<TSelectData, TError>;\n  /**\n   * Find purchase order by ID\n   * @param orderId ID of pet that needs to be fetched\n   * @return successful operation\n   */\n  static useGetOrderByIdQuery<TSelectData = Order, TError = unknown>(\n    orderId: number,\n    options?: UseQueryOptions<Order, TError, TSelectData>,\n  ): UseQueryResult<TSelectData, TError>;\n  static useGetOrderByIdQuery<TSelectData = Order, TError = unknown>(\n    ...params: any[]\n  ): UseQueryResult<TSelectData, TError> {\n    let options:\n      | UseQueryOptions<Order, TError, TSelectData>\n      | undefined = undefined;\n    let orderId: any = undefined;\n\n    if (params.length > 0) {\n      if (isParameterObject(params[0])) {\n        ({ orderId } = params[0] as GetOrderByIdQueryParameters);\n        options = params[1];\n      } else {\n        [orderId, options] = params;\n      }\n    }\n\n    return useQuery<Order, TError, TSelectData>({\n      queryFn: Query.getOrderById,\n      queryKey: Query.getOrderByIdQueryKey(orderId),\n      ...((Query.getOrderByIdDefaultOptions as unknown) as UseQueryOptions<\n        Order,\n        TError,\n        TSelectData\n      >),\n      ...options,\n    });\n  }\n  /**\n   * Find purchase order by ID\n   * @param orderId ID of pet that needs to be fetched\n   * @return successful operation\n   */\n  static setGetOrderByIdData(\n    queryClient: QueryClient,\n    updater: (data: Order | undefined) => Order,\n    orderId: number,\n  ) {\n    queryClient.setQueryData(Query.getOrderByIdQueryKey(orderId), updater);\n  }\n\n  /**\n   * Find purchase order by ID\n   * @param orderId ID of pet that needs to be fetched\n   * @return successful operation\n   */\n  static setGetOrderByIdDataByQueryId(\n    queryClient: QueryClient,\n    queryKey: QueryKey,\n    updater: (data: Order | undefined) => Order,\n  ) {\n    queryClient.setQueryData(queryKey, updater);\n  }\n\n  getInventory(): string {\n    let url_ = this.baseUrl + '/store/inventory';\n    url_ = url_.replace(/[?&]$/, '');\n    return url_;\n  }\n\n  static getInventoryDefaultOptions?: UseQueryOptions<\n    { [key: string]: number },\n    unknown,\n    { [key: string]: number }\n  > = {};\n  public static getInventoryQueryKey(): QueryKey;\n  public static getInventoryQueryKey(...params: any[]): QueryKey {\n    return removeUndefinedFromArrayTail(['Client', 'getInventory']);\n  }\n\n  private static getInventory() {\n    return Query.Client.getInventory();\n  }\n\n  /**\n   * Returns pet inventories by status\n   * @return successful operation\n   */\n  static useGetInventoryQuery<\n    TSelectData = { [key: string]: number },\n    TError = unknown\n  >(\n    options?: UseQueryOptions<{ [key: string]: number }, TError, TSelectData>,\n  ): UseQueryResult<TSelectData, TError>;\n  static useGetInventoryQuery<\n    TSelectData = { [key: string]: number },\n    TError = unknown\n  >(...params: any[]): UseQueryResult<TSelectData, TError> {\n    let options:\n      | UseQueryOptions<{ [key: string]: number }, TError, TSelectData>\n      | undefined = undefined;\n\n    options = params[0] as any;\n\n    return useQuery<{ [key: string]: number }, TError, TSelectData>({\n      queryFn: Query.getInventory,\n      queryKey: Query.getInventoryQueryKey(),\n      ...((Query.getInventoryDefaultOptions as unknown) as UseQueryOptions<\n        { [key: string]: number },\n        TError,\n        TSelectData\n      >),\n      ...options,\n    });\n  }\n  /**\n   * Returns pet inventories by status\n   * @return successful operation\n   */\n  static setGetInventoryData(\n    queryClient: QueryClient,\n    updater: (\n      data: { [key: string]: number } | undefined,\n    ) => { [key: string]: number },\n  ) {\n    queryClient.setQueryData(Query.getInventoryQueryKey(), updater);\n  }\n\n  /**\n   * Returns pet inventories by status\n   * @return successful operation\n   */\n  static setGetInventoryDataByQueryId(\n    queryClient: QueryClient,\n    queryKey: QueryKey,\n    updater: (\n      data: { [key: string]: number } | undefined,\n    ) => { [key: string]: number },\n  ) {\n    queryClient.setQueryData(queryKey, updater);\n  }\n\n  getUserByName(username: string): string {\n    let url_ = this.baseUrl + '/user/{username}';\n    if (username === undefined || username === null)\n      throw new Error(\"The parameter 'username' must be defined.\");\n    url_ = url_.replace('{username}', encodeURIComponent('' + username));\n    url_ = url_.replace(/[?&]$/, '');\n    return url_;\n  }\n\n  static getUserByNameDefaultOptions?: UseQueryOptions<\n    User,\n    unknown,\n    User\n  > = {};\n  public static getUserByNameQueryKey(username: string): QueryKey;\n  public static getUserByNameQueryKey(...params: any[]): QueryKey {\n    if (params.length === 1 && isParameterObject(params[0])) {\n      const { username } = params[0] as GetUserByNameQueryParameters;\n\n      return removeUndefinedFromArrayTail([\n        'Client',\n        'getUserByName',\n        username as any,\n      ]);\n    } else {\n      return removeUndefinedFromArrayTail([\n        'Client',\n        'getUserByName',\n        ...params,\n      ]);\n    }\n  }\n\n  private static getUserByName(context: QueryFunctionContext) {\n    return Query.Client.getUserByName(context.queryKey[2] as string);\n  }\n\n  static useGetUserByNameQuery<TSelectData = User, TError = unknown>(\n    dto: GetUserByNameQueryParameters,\n    options?: UseQueryOptions<User, TError, TSelectData>,\n  ): UseQueryResult<TSelectData, TError>;\n  /**\n   * Get user by user name\n   * @param username The name that needs to be fetched. Use user1 for testing.\n   * @return successful operation\n   */\n  static useGetUserByNameQuery<TSelectData = User, TError = unknown>(\n    username: string,\n    options?: UseQueryOptions<User, TError, TSelectData>,\n  ): UseQueryResult<TSelectData, TError>;\n  static useGetUserByNameQuery<TSelectData = User, TError = unknown>(\n    ...params: any[]\n  ): UseQueryResult<TSelectData, TError> {\n    let options:\n      | UseQueryOptions<User, TError, TSelectData>\n      | undefined = undefined;\n    let username: any = undefined;\n\n    if (params.length > 0) {\n      if (isParameterObject(params[0])) {\n        ({ username } = params[0] as GetUserByNameQueryParameters);\n        options = params[1];\n      } else {\n        [username, options] = params;\n      }\n    }\n\n    return useQuery<User, TError, TSelectData>({\n      queryFn: Query.getUserByName,\n      queryKey: Query.getUserByNameQueryKey(username),\n      ...((Query.getUserByNameDefaultOptions as unknown) as UseQueryOptions<\n        User,\n        TError,\n        TSelectData\n      >),\n      ...options,\n    });\n  }\n  /**\n   * Get user by user name\n   * @param username The name that needs to be fetched. Use user1 for testing.\n   * @return successful operation\n   */\n  static setGetUserByNameData(\n    queryClient: QueryClient,\n    updater: (data: User | undefined) => User,\n    username: string,\n  ) {\n    queryClient.setQueryData(Query.getUserByNameQueryKey(username), updater);\n  }\n\n  /**\n   * Get user by user name\n   * @param username The name that needs to be fetched. Use user1 for testing.\n   * @return successful operation\n   */\n  static setGetUserByNameDataByQueryId(\n    queryClient: QueryClient,\n    queryKey: QueryKey,\n    updater: (data: User | undefined) => User,\n  ) {\n    queryClient.setQueryData(queryKey, updater);\n  }\n\n  loginUser(username: string, password: string): string {\n    let url_ = this.baseUrl + '/user/login?';\n    if (username === undefined || username === null)\n      throw new Error(\n        \"The parameter 'username' must be defined and cannot be null.\",\n      );\n    else url_ += 'username=' + encodeURIComponent('' + username) + '&';\n    if (password === undefined || password === null)\n      throw new Error(\n        \"The parameter 'password' must be defined and cannot be null.\",\n      );\n    else url_ += 'password=' + encodeURIComponent('' + password) + '&';\n    url_ = url_.replace(/[?&]$/, '');\n    return url_;\n  }\n\n  static loginUserDefaultOptions?: UseQueryOptions<\n    string,\n    unknown,\n    string\n  > = {};\n  public static loginUserQueryKey(dto: LoginUserQueryParameters): QueryKey;\n  public static loginUserQueryKey(username: string, password: string): QueryKey;\n  public static loginUserQueryKey(...params: any[]): QueryKey {\n    if (params.length === 1 && isParameterObject(params[0])) {\n      const { username, password } = params[0] as LoginUserQueryParameters;\n\n      return removeUndefinedFromArrayTail([\n        'Client',\n        'loginUser',\n        username as any,\n        password as any,\n      ]);\n    } else {\n      return removeUndefinedFromArrayTail(['Client', 'loginUser', ...params]);\n    }\n  }\n\n  private static loginUser(context: QueryFunctionContext) {\n    return Query.Client.loginUser(\n      context.queryKey[2] as string,\n      context.queryKey[3] as string,\n    );\n  }\n\n  static useLoginUserQuery<TSelectData = string, TError = unknown>(\n    dto: LoginUserQueryParameters,\n    options?: UseQueryOptions<string, TError, TSelectData>,\n  ): UseQueryResult<TSelectData, TError>;\n  /**\n   * Logs user into the system\n   * @param username The user name for login\n   * @param password The password for login in clear text\n   * @return successful operation\n   */\n  static useLoginUserQuery<TSelectData = string, TError = unknown>(\n    username: string,\n    password: string,\n    options?: UseQueryOptions<string, TError, TSelectData>,\n  ): UseQueryResult<TSelectData, TError>;\n  static useLoginUserQuery<TSelectData = string, TError = unknown>(\n    ...params: any[]\n  ): UseQueryResult<TSelectData, TError> {\n    let options:\n      | UseQueryOptions<string, TError, TSelectData>\n      | undefined = undefined;\n    let username: any = undefined;\n    let password: any = undefined;\n\n    if (params.length > 0) {\n      if (isParameterObject(params[0])) {\n        ({ username, password } = params[0] as LoginUserQueryParameters);\n        options = params[1];\n      } else {\n        [username, password, options] = params;\n      }\n    }\n\n    return useQuery<string, TError, TSelectData>({\n      queryFn: Query.loginUser,\n      queryKey: Query.loginUserQueryKey(username, password),\n      ...((Query.loginUserDefaultOptions as unknown) as UseQueryOptions<\n        string,\n        TError,\n        TSelectData\n      >),\n      ...options,\n    });\n  }\n  /**\n   * Logs user into the system\n   * @param username The user name for login\n   * @param password The password for login in clear text\n   * @return successful operation\n   */\n  static setLoginUserData(\n    queryClient: QueryClient,\n    updater: (data: string | undefined) => string,\n    username: string,\n    password: string,\n  ) {\n    queryClient.setQueryData(\n      Query.loginUserQueryKey(username, password),\n      updater,\n    );\n  }\n\n  /**\n   * Logs user into the system\n   * @param username The user name for login\n   * @param password The password for login in clear text\n   * @return successful operation\n   */\n  static setLoginUserDataByQueryId(\n    queryClient: QueryClient,\n    queryKey: QueryKey,\n    updater: (data: string | undefined) => string,\n  ) {\n    queryClient.setQueryData(queryKey, updater);\n  }\n\n  logoutUser(): string {\n    let url_ = this.baseUrl + '/user/logout';\n    url_ = url_.replace(/[?&]$/, '');\n    return url_;\n  }\n\n  static logoutUserDefaultOptions?: UseQueryOptions<void, unknown, void> = {};\n  public static logoutUserQueryKey(): QueryKey;\n  public static logoutUserQueryKey(...params: any[]): QueryKey {\n    return removeUndefinedFromArrayTail(['Client', 'logoutUser']);\n  }\n\n  private static logoutUser() {\n    return Query.Client.logoutUser();\n  }\n\n  /**\n   * Logs out current logged in user session\n   * @return successful operation\n   */\n  static useLogoutUserQuery<TSelectData = void, TError = unknown>(\n    options?: UseQueryOptions<void, TError, TSelectData>,\n  ): UseQueryResult<TSelectData, TError>;\n  static useLogoutUserQuery<TSelectData = void, TError = unknown>(\n    ...params: any[]\n  ): UseQueryResult<TSelectData, TError> {\n    let options:\n      | UseQueryOptions<void, TError, TSelectData>\n      | undefined = undefined;\n\n    options = params[0] as any;\n\n    return useQuery<void, TError, TSelectData>({\n      queryFn: Query.logoutUser,\n      queryKey: Query.logoutUserQueryKey(),\n      ...((Query.logoutUserDefaultOptions as unknown) as UseQueryOptions<\n        void,\n        TError,\n        TSelectData\n      >),\n      ...options,\n    });\n  }\n  /**\n   * Logs out current logged in user session\n   * @return successful operation\n   */\n  static setLogoutUserData(\n    queryClient: QueryClient,\n    updater: (data: void | undefined) => void,\n  ) {\n    queryClient.setQueryData(Query.logoutUserQueryKey(), updater);\n  }\n\n  /**\n   * Logs out current logged in user session\n   * @return successful operation\n   */\n  static setLogoutUserDataByQueryId(\n    queryClient: QueryClient,\n    queryKey: QueryKey,\n    updater: (data: void | undefined) => void,\n  ) {\n    queryClient.setQueryData(queryKey, updater);\n  }\n}\n\nexport class ApiResponse implements IApiResponse {\n  code?: number | undefined;\n  type?: string | undefined;\n  message?: string | undefined;\n\n  constructor(data?: IApiResponse) {\n    if (data) {\n      for (var property in data) {\n        if (data.hasOwnProperty(property))\n          (<any>this)[property] = (<any>data)[property];\n      }\n    }\n  }\n\n  init(_data?: any) {\n    if (_data) {\n      this.code = _data['code'];\n      this.type = _data['type'];\n      this.message = _data['message'];\n    }\n  }\n\n  static fromJS(data: any): ApiResponse {\n    data = typeof data === 'object' ? data : {};\n    let result = new ApiResponse();\n    result.init(data);\n    return result;\n  }\n\n  toJSON(data?: any) {\n    data = typeof data === 'object' ? data : {};\n    data['code'] = this.code;\n    data['type'] = this.type;\n    data['message'] = this.message;\n    return data;\n  }\n}\n\nexport interface IApiResponse {\n  code?: number | undefined;\n  type?: string | undefined;\n  message?: string | undefined;\n}\n\nexport class Category implements ICategory {\n  id?: number | undefined;\n  name?: string | undefined;\n\n  constructor(data?: ICategory) {\n    if (data) {\n      for (var property in data) {\n        if (data.hasOwnProperty(property))\n          (<any>this)[property] = (<any>data)[property];\n      }\n    }\n  }\n\n  init(_data?: any) {\n    if (_data) {\n      this.id = _data['id'];\n      this.name = _data['name'];\n    }\n  }\n\n  static fromJS(data: any): Category {\n    data = typeof data === 'object' ? data : {};\n    let result = new Category();\n    result.init(data);\n    return result;\n  }\n\n  toJSON(data?: any) {\n    data = typeof data === 'object' ? data : {};\n    data['id'] = this.id;\n    data['name'] = this.name;\n    return data;\n  }\n}\n\nexport interface ICategory {\n  id?: number | undefined;\n  name?: string | undefined;\n}\n\nexport class Pet implements IPet {\n  id?: number | undefined;\n  category?: Category | undefined;\n  name!: string;\n  photoUrls!: string[];\n  tags?: Tag[] | undefined;\n  /** pet status in the store */\n  status?: PetStatus | undefined;\n\n  constructor(data?: IPet) {\n    if (data) {\n      for (var property in data) {\n        if (data.hasOwnProperty(property))\n          (<any>this)[property] = (<any>data)[property];\n      }\n    }\n    if (!data) {\n      this.photoUrls = [];\n    }\n  }\n\n  init(_data?: any) {\n    if (_data) {\n      this.id = _data['id'];\n      this.category = _data['category']\n        ? Category.fromJS(_data['category'])\n        : <any>undefined;\n      this.name = _data['name'];\n      if (Array.isArray(_data['photoUrls'])) {\n        this.photoUrls = [] as any;\n        for (let item of _data['photoUrls']) this.photoUrls!.push(item);\n      }\n      if (Array.isArray(_data['tags'])) {\n        this.tags = [] as any;\n        for (let item of _data['tags']) this.tags!.push(Tag.fromJS(item));\n      }\n      this.status = _data['status'];\n    }\n  }\n\n  static fromJS(data: any): Pet {\n    data = typeof data === 'object' ? data : {};\n    let result = new Pet();\n    result.init(data);\n    return result;\n  }\n\n  toJSON(data?: any) {\n    data = typeof data === 'object' ? data : {};\n    data['id'] = this.id;\n    data['category'] = this.category ? this.category.toJSON() : <any>undefined;\n    data['name'] = this.name;\n    if (Array.isArray(this.photoUrls)) {\n      data['photoUrls'] = [];\n      for (let item of this.photoUrls) data['photoUrls'].push(item);\n    }\n    if (Array.isArray(this.tags)) {\n      data['tags'] = [];\n      for (let item of this.tags) data['tags'].push(item.toJSON());\n    }\n    data['status'] = this.status;\n    return data;\n  }\n}\n\nexport interface IPet {\n  id?: number | undefined;\n  category?: Category | undefined;\n  name: string;\n  photoUrls: string[];\n  tags?: Tag[] | undefined;\n  /** pet status in the store */\n  status?: PetStatus | undefined;\n}\n\nexport class Tag implements ITag {\n  id?: number | undefined;\n  name?: string | undefined;\n\n  constructor(data?: ITag) {\n    if (data) {\n      for (var property in data) {\n        if (data.hasOwnProperty(property))\n          (<any>this)[property] = (<any>data)[property];\n      }\n    }\n  }\n\n  init(_data?: any) {\n    if (_data) {\n      this.id = _data['id'];\n      this.name = _data['name'];\n    }\n  }\n\n  static fromJS(data: any): Tag {\n    data = typeof data === 'object' ? data : {};\n    let result = new Tag();\n    result.init(data);\n    return result;\n  }\n\n  toJSON(data?: any) {\n    data = typeof data === 'object' ? data : {};\n    data['id'] = this.id;\n    data['name'] = this.name;\n    return data;\n  }\n}\n\nexport interface ITag {\n  id?: number | undefined;\n  name?: string | undefined;\n}\n\nexport class Order implements IOrder {\n  id?: number | undefined;\n  petId?: number | undefined;\n  quantity?: number | undefined;\n  shipDate?: Date | undefined;\n  /** Order Status */\n  status?: OrderStatus | undefined;\n  complete?: boolean | undefined;\n\n  constructor(data?: IOrder) {\n    if (data) {\n      for (var property in data) {\n        if (data.hasOwnProperty(property))\n          (<any>this)[property] = (<any>data)[property];\n      }\n    }\n  }\n\n  init(_data?: any) {\n    if (_data) {\n      this.id = _data['id'];\n      this.petId = _data['petId'];\n      this.quantity = _data['quantity'];\n      this.shipDate = _data['shipDate']\n        ? new Date(_data['shipDate'].toString())\n        : <any>undefined;\n      this.status = _data['status'];\n      this.complete = _data['complete'];\n    }\n  }\n\n  static fromJS(data: any): Order {\n    data = typeof data === 'object' ? data : {};\n    let result = new Order();\n    result.init(data);\n    return result;\n  }\n\n  toJSON(data?: any) {\n    data = typeof data === 'object' ? data : {};\n    data['id'] = this.id;\n    data['petId'] = this.petId;\n    data['quantity'] = this.quantity;\n    data['shipDate'] = this.shipDate\n      ? this.shipDate.toISOString()\n      : <any>undefined;\n    data['status'] = this.status;\n    data['complete'] = this.complete;\n    return data;\n  }\n}\n\nexport interface IOrder {\n  id?: number | undefined;\n  petId?: number | undefined;\n  quantity?: number | undefined;\n  shipDate?: Date | undefined;\n  /** Order Status */\n  status?: OrderStatus | undefined;\n  complete?: boolean | undefined;\n}\n\nexport class User implements IUser {\n  id?: number | undefined;\n  username?: string | undefined;\n  firstName?: string | undefined;\n  lastName?: string | undefined;\n  email?: string | undefined;\n  password?: string | undefined;\n  phone?: string | undefined;\n  /** User Status */\n  userStatus?: number | undefined;\n\n  constructor(data?: IUser) {\n    if (data) {\n      for (var property in data) {\n        if (data.hasOwnProperty(property))\n          (<any>this)[property] = (<any>data)[property];\n      }\n    }\n  }\n\n  init(_data?: any) {\n    if (_data) {\n      this.id = _data['id'];\n      this.username = _data['username'];\n      this.firstName = _data['firstName'];\n      this.lastName = _data['lastName'];\n      this.email = _data['email'];\n      this.password = _data['password'];\n      this.phone = _data['phone'];\n      this.userStatus = _data['userStatus'];\n    }\n  }\n\n  static fromJS(data: any): User {\n    data = typeof data === 'object' ? data : {};\n    let result = new User();\n    result.init(data);\n    return result;\n  }\n\n  toJSON(data?: any) {\n    data = typeof data === 'object' ? data : {};\n    data['id'] = this.id;\n    data['username'] = this.username;\n    data['firstName'] = this.firstName;\n    data['lastName'] = this.lastName;\n    data['email'] = this.email;\n    data['password'] = this.password;\n    data['phone'] = this.phone;\n    data['userStatus'] = this.userStatus;\n    return data;\n  }\n}\n\nexport interface IUser {\n  id?: number | undefined;\n  username?: string | undefined;\n  firstName?: string | undefined;\n  lastName?: string | undefined;\n  email?: string | undefined;\n  password?: string | undefined;\n  phone?: string | undefined;\n  /** User Status */\n  userStatus?: number | undefined;\n}\n\nexport enum Status {\n  Available = 'available',\n  Pending = 'pending',\n  Sold = 'sold',\n}\n\nexport enum PetStatus {\n  Available = 'available',\n  Pending = 'pending',\n  Sold = 'sold',\n}\n\nexport enum OrderStatus {\n  Placed = 'placed',\n  Approved = 'approved',\n  Delivered = 'delivered',\n}\n\nexport interface FileParameter {\n  data: any;\n  fileName: string;\n}\n\nexport class ApiException extends Error {\n  message: string;\n  status: number;\n  response: string;\n  headers: { [key: string]: any };\n  result: any;\n\n  constructor(\n    message: string,\n    status: number,\n    response: string,\n    headers: { [key: string]: any },\n    result: any,\n  ) {\n    super();\n\n    this.message = message;\n    this.status = status;\n    this.response = response;\n    this.headers = headers;\n    this.result = result;\n  }\n\n  protected isApiException = true;\n\n  static isApiException(obj: any): obj is ApiException {\n    return obj.isApiException === true;\n  }\n}\n\nfunction throwException(\n  message: string,\n  status: number,\n  response: string,\n  headers: { [key: string]: any },\n  result?: any,\n): any {\n  if (result !== null && result !== undefined) throw result;\n  else throw new ApiException(message, status, response, headers, null);\n}\n\nimport {\n  useQuery,\n  UseQueryResult,\n  QueryFunctionContext,\n  UseQueryOptions,\n  QueryClient,\n  QueryKey,\n} from 'react-query';\nimport { PersistedClient } from 'react-query/persistQueryClient-experimental';\n\nfunction removeUndefinedFromArrayTail<T>(arr: T[]): T[] {\n  let lastDefinedValueIndex = arr.length - 1;\n  while (lastDefinedValueIndex >= 0) {\n    if (arr[lastDefinedValueIndex] === undefined) {\n      lastDefinedValueIndex--;\n    } else {\n      break;\n    }\n  }\n  return lastDefinedValueIndex === arr.length - 1\n    ? arr\n    : arr.slice(0, lastDefinedValueIndex + 1);\n}\n\n/*\n  Determines if first parameter of useSomethingQuery is an object with query parameters, or it's a regular parameter\n  Returns true if parameter is Object\n  Returns false if parameter is number/string/boolean/Date or Array\n*/\nfunction isParameterObject(param: unknown) {\n  if (param === null || param === undefined) return false;\n  if (param instanceof Array) return false;\n  const isObject = typeof param === 'object';\n  if (!isObject) return false;\n  if (param instanceof Date) return false;\n  return true;\n}\n\ntype ClientFactoryFunction = <T>(type: new (...params: any[]) => T) => T;\nlet _clientFactoryFunction: ClientFactoryFunction = <T>(\n  type: new (...params: any[]) => T,\n) => {\n  const params = [_baseUrl, _fetchFactory()];\n  return new type(...params);\n};\n/*\n  Overrides default Client factory function\n*/\nexport function setClientFactory(value: ClientFactoryFunction) {\n  _clientFactoryFunction = value;\n}\n\n/*\n  Returns current Client factory function\n*/\nexport function getClientFactory() {\n  return _clientFactoryFunction;\n}\n\n/*\n  Function that will be called from `useQuery...` methods to get a client of certain type\n*/\nfunction createClient<T>(type: new () => T) {\n  return _clientFactoryFunction(type);\n}\n\nlet _baseUrl = '';\n/*\n  Returns the base URL for http requests\n*/\nexport function getBaseUrl(): string {\n  return _baseUrl;\n}\n\n/*\n  Sets the base URL for http requests\n*/\nexport function setBaseUrl(baseUrl: string) {\n  _baseUrl = baseUrl;\n}\n\nlet _fetchFactory = () => <any>window;\n/*\n  Returns currently used factory for fetch\n*/\nexport function getFetchFactory(): () => {\n  fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;\n} {\n  return _fetchFactory;\n}\n/*\n  Sets currently used factory for fetch\n*/\nexport function setFetchFactory(\n  factory: () => {\n    fetch(url: RequestInfo, init?: RequestInit): Promise<Response>;\n  },\n) {\n  _fetchFactory = factory;\n}\n\nfunction parseDateOnly(s: string) {\n  const date = new Date(s);\n  return new Date(date.getTime() + date.getTimezoneOffset() * 60000);\n}\nexport function persistorDeserialize(cache: string): PersistedClient {\n  const client: PersistedClient = JSON.parse(cache);\n\n  client.clientState.queries.forEach((query, i) => {\n    const data: any = query.state.data;\n\n    query.state.data = constructDtoClass(query.queryKey, data);\n  });\n\n  return client;\n}\n\nfunction constructDtoClass(queryKey: QueryKey, data: any): unknown {\n  const resultTypeKey = getResultTypeClassKey(queryKey);\n  const constructorFunction = resultTypesByQueryKey[resultTypeKey];\n\n  if (!constructorFunction) {\n    return data;\n  }\n\n  const dto = constructorFunction();\n  dto.init(data);\n\n  return dto;\n}\n\nfunction getResultTypeClassKey(queryKey: QueryKey): string {\n  if (!Array.isArray(queryKey)) {\n    return queryKey as string;\n  }\n  if (queryKey.length >= 2) {\n    // We concatenate first and second elements, because they uniquely identify the query.\n    // All other QueryKey elements are query parameters\n    return `${queryKey[0]}___${queryKey[1]}`;\n  }\n\n  // We actually should never reach this point :)\n  return queryKey.join('___');\n}\n","C:\\Work\\react-query-swagger\\examples\\pet-client\\src\\App.tsx",["38","39","40","41","42","43"],"C:\\Work\\react-query-swagger\\examples\\pet-client\\src\\api\\axios-client.ts",["44","45"],"const resultTypesByQueryKey: Record<string, () => { init(data: any): void }> =\n  {};\n\n/* tslint:disable */\n/* eslint-disable */\n//----------------------\n// <auto-generated>\n//     Generated using the NSwag toolchain v13.15.10.0 (NJsonSchema v10.6.10.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)\n// </auto-generated>\n//----------------------\n// ReSharper disable InconsistentNaming\n\nimport axios, {\n  AxiosError,\n  AxiosInstance,\n  AxiosRequestConfig,\n  AxiosResponse,\n  CancelToken,\n} from 'axios';\n\nexport class Client {\n  private instance: AxiosInstance;\n  private baseUrl: string;\n  protected jsonParseReviver: ((key: string, value: any) => any) | undefined =\n    undefined;\n\n  constructor(baseUrl?: string, instance?: AxiosInstance) {\n    this.instance = instance ? instance : axios.create();\n\n    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : '/v2';\n  }\n\n  /**\n   * uploads an image\n   * @param petId ID of pet to update\n   * @param additionalMetadata (optional) Additional data to pass to server\n   * @param file (optional) file to upload\n   * @return successful operation\n   */\n  uploadFile(\n    petId: number,\n    additionalMetadata?: string | null | undefined,\n    file?: FileParameter | null | undefined,\n    cancelToken?: CancelToken | undefined,\n  ): Promise<ApiResponse> {\n    let url_ = this.baseUrl + '/pet/{petId}/uploadImage';\n    if (petId === undefined || petId === null)\n      throw new Error(\"The parameter 'petId' must be defined.\");\n    url_ = url_.replace('{petId}', encodeURIComponent('' + petId));\n    url_ = url_.replace(/[?&]$/, '');\n\n    const content_ = new FormData();\n    if (additionalMetadata !== null && additionalMetadata !== undefined)\n      content_.append('additionalMetadata', additionalMetadata.toString());\n    if (file !== null && file !== undefined)\n      content_.append(\n        'file',\n        file.data,\n        file.fileName ? file.fileName : 'file',\n      );\n\n    let options_ = <AxiosRequestConfig>{\n      data: content_,\n      method: 'POST',\n      url: url_,\n      headers: {\n        Accept: 'application/json',\n      },\n      cancelToken,\n    };\n\n    return this.instance\n      .request(options_)\n      .catch((_error: any) => {\n        if (isAxiosError(_error) && _error.response) {\n          return _error.response;\n        } else {\n          throw _error;\n        }\n      })\n      .then((_response: AxiosResponse) => {\n        return this.processUploadFile(_response);\n      });\n  }\n\n  protected processUploadFile(response: AxiosResponse): Promise<ApiResponse> {\n    const status = response.status;\n    let _headers: any = {};\n    if (response.headers && typeof response.headers === 'object') {\n      for (let k in response.headers) {\n        if (response.headers.hasOwnProperty(k)) {\n          _headers[k] = response.headers[k];\n        }\n      }\n    }\n    if (status === 200) {\n      const _responseText = response.data;\n      let result200: any = null;\n      let resultData200 = _responseText;\n      result200 = ApiResponse.fromJS(resultData200);\n      return Promise.resolve<ApiResponse>(result200);\n    } else if (status !== 200 && status !== 204) {\n      const _responseText = response.data;\n      return throwException(\n        'An unexpected server error occurred.',\n        status,\n        _responseText,\n        _headers,\n      );\n    }\n    return Promise.resolve<ApiResponse>(null as any);\n  }\n\n  /**\n   * Add a new pet to the store\n   * @param body Pet object that needs to be added to the store\n   */\n  addPet(body: Pet, cancelToken?: CancelToken | undefined): Promise<void> {\n    let url_ = this.baseUrl + '/pet';\n    url_ = url_.replace(/[?&]$/, '');\n\n    const content_ = JSON.stringify(body);\n\n    let options_ = <AxiosRequestConfig>{\n      data: content_,\n      method: 'POST',\n      url: url_,\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      cancelToken,\n    };\n\n    return this.instance\n      .request(options_)\n      .catch((_error: any) => {\n        if (isAxiosError(_error) && _error.response) {\n          return _error.response;\n        } else {\n          throw _error;\n        }\n      })\n      .then((_response: AxiosResponse) => {\n        return this.processAddPet(_response);\n      });\n  }\n\n  protected processAddPet(response: AxiosResponse): Promise<void> {\n    const status = response.status;\n    let _headers: any = {};\n    if (response.headers && typeof response.headers === 'object') {\n      for (let k in response.headers) {\n        if (response.headers.hasOwnProperty(k)) {\n          _headers[k] = response.headers[k];\n        }\n      }\n    }\n    if (status === 405) {\n      const _responseText = response.data;\n      return throwException('Invalid input', status, _responseText, _headers);\n    } else if (status !== 200 && status !== 204) {\n      const _responseText = response.data;\n      return throwException(\n        'An unexpected server error occurred.',\n        status,\n        _responseText,\n        _headers,\n      );\n    }\n    return Promise.resolve<void>(null as any);\n  }\n\n  /**\n   * Update an existing pet\n   * @param body Pet object that needs to be added to the store\n   */\n  updatePet(body: Pet, cancelToken?: CancelToken | undefined): Promise<void> {\n    let url_ = this.baseUrl + '/pet';\n    url_ = url_.replace(/[?&]$/, '');\n\n    const content_ = JSON.stringify(body);\n\n    let options_ = <AxiosRequestConfig>{\n      data: content_,\n      method: 'PUT',\n      url: url_,\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      cancelToken,\n    };\n\n    return this.instance\n      .request(options_)\n      .catch((_error: any) => {\n        if (isAxiosError(_error) && _error.response) {\n          return _error.response;\n        } else {\n          throw _error;\n        }\n      })\n      .then((_response: AxiosResponse) => {\n        return this.processUpdatePet(_response);\n      });\n  }\n\n  protected processUpdatePet(response: AxiosResponse): Promise<void> {\n    const status = response.status;\n    let _headers: any = {};\n    if (response.headers && typeof response.headers === 'object') {\n      for (let k in response.headers) {\n        if (response.headers.hasOwnProperty(k)) {\n          _headers[k] = response.headers[k];\n        }\n      }\n    }\n    if (status === 400) {\n      const _responseText = response.data;\n      return throwException(\n        'Invalid ID supplied',\n        status,\n        _responseText,\n        _headers,\n      );\n    } else if (status === 404) {\n      const _responseText = response.data;\n      return throwException('Pet not found', status, _responseText, _headers);\n    } else if (status === 405) {\n      const _responseText = response.data;\n      return throwException(\n        'Validation exception',\n        status,\n        _responseText,\n        _headers,\n      );\n    } else if (status !== 200 && status !== 204) {\n      const _responseText = response.data;\n      return throwException(\n        'An unexpected server error occurred.',\n        status,\n        _responseText,\n        _headers,\n      );\n    }\n    return Promise.resolve<void>(null as any);\n  }\n\n  /**\n   * Finds Pets by status\n   * @param status Status values that need to be considered for filter\n   * @return successful operation\n   */\n  findPetsByStatus(\n    status: Status[],\n    cancelToken?: CancelToken | undefined,\n  ): Promise<Pet[]> {\n    let url_ = this.baseUrl + '/pet/findByStatus?';\n    if (status === undefined || status === null)\n      throw new Error(\n        \"The parameter 'status' must be defined and cannot be null.\",\n      );\n    else\n      status &&\n        status.forEach((item) => {\n          url_ += 'status=' + encodeURIComponent('' + item) + '&';\n        });\n    url_ = url_.replace(/[?&]$/, '');\n\n    let options_ = <AxiosRequestConfig>{\n      method: 'GET',\n      url: url_,\n      headers: {\n        Accept: 'application/json',\n      },\n      cancelToken,\n    };\n\n    return this.instance\n      .request(options_)\n      .catch((_error: any) => {\n        if (isAxiosError(_error) && _error.response) {\n          return _error.response;\n        } else {\n          throw _error;\n        }\n      })\n      .then((_response: AxiosResponse) => {\n        return this.processFindPetsByStatus(_response);\n      });\n  }\n\n  protected processFindPetsByStatus(response: AxiosResponse): Promise<Pet[]> {\n    const status = response.status;\n    let _headers: any = {};\n    if (response.headers && typeof response.headers === 'object') {\n      for (let k in response.headers) {\n        if (response.headers.hasOwnProperty(k)) {\n          _headers[k] = response.headers[k];\n        }\n      }\n    }\n    if (status === 200) {\n      const _responseText = response.data;\n      let result200: any = null;\n      let resultData200 = _responseText;\n      if (Array.isArray(resultData200)) {\n        result200 = [] as any;\n        for (let item of resultData200) result200!.push(Pet.fromJS(item));\n      } else {\n        result200 = <any>null;\n      }\n      return Promise.resolve<Pet[]>(result200);\n    } else if (status === 400) {\n      const _responseText = response.data;\n      return throwException(\n        'Invalid status value',\n        status,\n        _responseText,\n        _headers,\n      );\n    } else if (status !== 200 && status !== 204) {\n      const _responseText = response.data;\n      return throwException(\n        'An unexpected server error occurred.',\n        status,\n        _responseText,\n        _headers,\n      );\n    }\n    return Promise.resolve<Pet[]>(null as any);\n  }\n\n  /**\n   * Finds Pets by tags\n   * @param tags Tags to filter by\n   * @return successful operation\n   * @deprecated\n   */\n  findPetsByTags(\n    tags: string[],\n    cancelToken?: CancelToken | undefined,\n  ): Promise<Pet[]> {\n    let url_ = this.baseUrl + '/pet/findByTags?';\n    if (tags === undefined || tags === null)\n      throw new Error(\n        \"The parameter 'tags' must be defined and cannot be null.\",\n      );\n    else\n      tags &&\n        tags.forEach((item) => {\n          url_ += 'tags=' + encodeURIComponent('' + item) + '&';\n        });\n    url_ = url_.replace(/[?&]$/, '');\n\n    let options_ = <AxiosRequestConfig>{\n      method: 'GET',\n      url: url_,\n      headers: {\n        Accept: 'application/json',\n      },\n      cancelToken,\n    };\n\n    return this.instance\n      .request(options_)\n      .catch((_error: any) => {\n        if (isAxiosError(_error) && _error.response) {\n          return _error.response;\n        } else {\n          throw _error;\n        }\n      })\n      .then((_response: AxiosResponse) => {\n        return this.processFindPetsByTags(_response);\n      });\n  }\n\n  protected processFindPetsByTags(response: AxiosResponse): Promise<Pet[]> {\n    const status = response.status;\n    let _headers: any = {};\n    if (response.headers && typeof response.headers === 'object') {\n      for (let k in response.headers) {\n        if (response.headers.hasOwnProperty(k)) {\n          _headers[k] = response.headers[k];\n        }\n      }\n    }\n    if (status === 200) {\n      const _responseText = response.data;\n      let result200: any = null;\n      let resultData200 = _responseText;\n      if (Array.isArray(resultData200)) {\n        result200 = [] as any;\n        for (let item of resultData200) result200!.push(Pet.fromJS(item));\n      } else {\n        result200 = <any>null;\n      }\n      return Promise.resolve<Pet[]>(result200);\n    } else if (status === 400) {\n      const _responseText = response.data;\n      return throwException(\n        'Invalid tag value',\n        status,\n        _responseText,\n        _headers,\n      );\n    } else if (status !== 200 && status !== 204) {\n      const _responseText = response.data;\n      return throwException(\n        'An unexpected server error occurred.',\n        status,\n        _responseText,\n        _headers,\n      );\n    }\n    return Promise.resolve<Pet[]>(null as any);\n  }\n\n  /**\n   * Find pet by ID\n   * @param petId ID of pet to return\n   * @return successful operation\n   */\n  getPetById(\n    petId: number,\n    cancelToken?: CancelToken | undefined,\n  ): Promise<Pet> {\n    let url_ = this.baseUrl + '/pet/{petId}';\n    if (petId === undefined || petId === null)\n      throw new Error(\"The parameter 'petId' must be defined.\");\n    url_ = url_.replace('{petId}', encodeURIComponent('' + petId));\n    url_ = url_.replace(/[?&]$/, '');\n\n    let options_ = <AxiosRequestConfig>{\n      method: 'GET',\n      url: url_,\n      headers: {\n        Accept: 'application/json',\n      },\n      cancelToken,\n    };\n\n    return this.instance\n      .request(options_)\n      .catch((_error: any) => {\n        if (isAxiosError(_error) && _error.response) {\n          return _error.response;\n        } else {\n          throw _error;\n        }\n      })\n      .then((_response: AxiosResponse) => {\n        return this.processGetPetById(_response);\n      });\n  }\n\n  protected processGetPetById(response: AxiosResponse): Promise<Pet> {\n    const status = response.status;\n    let _headers: any = {};\n    if (response.headers && typeof response.headers === 'object') {\n      for (let k in response.headers) {\n        if (response.headers.hasOwnProperty(k)) {\n          _headers[k] = response.headers[k];\n        }\n      }\n    }\n    if (status === 200) {\n      const _responseText = response.data;\n      let result200: any = null;\n      let resultData200 = _responseText;\n      result200 = Pet.fromJS(resultData200);\n      return Promise.resolve<Pet>(result200);\n    } else if (status === 400) {\n      const _responseText = response.data;\n      return throwException(\n        'Invalid ID supplied',\n        status,\n        _responseText,\n        _headers,\n      );\n    } else if (status === 404) {\n      const _responseText = response.data;\n      return throwException('Pet not found', status, _responseText, _headers);\n    } else if (status !== 200 && status !== 204) {\n      const _responseText = response.data;\n      return throwException(\n        'An unexpected server error occurred.',\n        status,\n        _responseText,\n        _headers,\n      );\n    }\n    return Promise.resolve<Pet>(null as any);\n  }\n\n  /**\n   * Updates a pet in the store with form data\n   * @param petId ID of pet that needs to be updated\n   * @param name (optional) Updated name of the pet\n   * @param status (optional) Updated status of the pet\n   */\n  updatePetWithForm(\n    petId: number,\n    name?: string | null | undefined,\n    status?: string | null | undefined,\n    cancelToken?: CancelToken | undefined,\n  ): Promise<void> {\n    let url_ = this.baseUrl + '/pet/{petId}';\n    if (petId === undefined || petId === null)\n      throw new Error(\"The parameter 'petId' must be defined.\");\n    url_ = url_.replace('{petId}', encodeURIComponent('' + petId));\n    url_ = url_.replace(/[?&]$/, '');\n\n    let content_ = '';\n    if (name !== undefined)\n      content_ +=\n        encodeURIComponent('name') + '=' + encodeURIComponent('' + name) + '&';\n    if (status !== undefined)\n      content_ +=\n        encodeURIComponent('status') +\n        '=' +\n        encodeURIComponent('' + status) +\n        '&';\n    content_ = content_.replace(/&$/, '');\n\n    let options_ = <AxiosRequestConfig>{\n      data: content_,\n      method: 'POST',\n      url: url_,\n      headers: {\n        'Content-Type': 'application/x-www-form-urlencoded',\n      },\n      cancelToken,\n    };\n\n    return this.instance\n      .request(options_)\n      .catch((_error: any) => {\n        if (isAxiosError(_error) && _error.response) {\n          return _error.response;\n        } else {\n          throw _error;\n        }\n      })\n      .then((_response: AxiosResponse) => {\n        return this.processUpdatePetWithForm(_response);\n      });\n  }\n\n  protected processUpdatePetWithForm(response: AxiosResponse): Promise<void> {\n    const status = response.status;\n    let _headers: any = {};\n    if (response.headers && typeof response.headers === 'object') {\n      for (let k in response.headers) {\n        if (response.headers.hasOwnProperty(k)) {\n          _headers[k] = response.headers[k];\n        }\n      }\n    }\n    if (status === 405) {\n      const _responseText = response.data;\n      return throwException('Invalid input', status, _responseText, _headers);\n    } else if (status !== 200 && status !== 204) {\n      const _responseText = response.data;\n      return throwException(\n        'An unexpected server error occurred.',\n        status,\n        _responseText,\n        _headers,\n      );\n    }\n    return Promise.resolve<void>(null as any);\n  }\n\n  /**\n   * Deletes a pet\n   * @param petId Pet id to delete\n   * @param api_key (optional)\n   */\n  deletePet(\n    petId: number,\n    api_key?: string | null | undefined,\n    cancelToken?: CancelToken | undefined,\n  ): Promise<void> {\n    let url_ = this.baseUrl + '/pet/{petId}';\n    if (petId === undefined || petId === null)\n      throw new Error(\"The parameter 'petId' must be defined.\");\n    url_ = url_.replace('{petId}', encodeURIComponent('' + petId));\n    url_ = url_.replace(/[?&]$/, '');\n\n    let options_ = <AxiosRequestConfig>{\n      method: 'DELETE',\n      url: url_,\n      headers: {\n        api_key: api_key !== undefined && api_key !== null ? '' + api_key : '',\n      },\n      cancelToken,\n    };\n\n    return this.instance\n      .request(options_)\n      .catch((_error: any) => {\n        if (isAxiosError(_error) && _error.response) {\n          return _error.response;\n        } else {\n          throw _error;\n        }\n      })\n      .then((_response: AxiosResponse) => {\n        return this.processDeletePet(_response);\n      });\n  }\n\n  protected processDeletePet(response: AxiosResponse): Promise<void> {\n    const status = response.status;\n    let _headers: any = {};\n    if (response.headers && typeof response.headers === 'object') {\n      for (let k in response.headers) {\n        if (response.headers.hasOwnProperty(k)) {\n          _headers[k] = response.headers[k];\n        }\n      }\n    }\n    if (status === 400) {\n      const _responseText = response.data;\n      return throwException(\n        'Invalid ID supplied',\n        status,\n        _responseText,\n        _headers,\n      );\n    } else if (status === 404) {\n      const _responseText = response.data;\n      return throwException('Pet not found', status, _responseText, _headers);\n    } else if (status !== 200 && status !== 204) {\n      const _responseText = response.data;\n      return throwException(\n        'An unexpected server error occurred.',\n        status,\n        _responseText,\n        _headers,\n      );\n    }\n    return Promise.resolve<void>(null as any);\n  }\n\n  /**\n   * Place an order for a pet\n   * @param body order placed for purchasing the pet\n   * @return successful operation\n   */\n  placeOrder(\n    body: Order,\n    cancelToken?: CancelToken | undefined,\n  ): Promise<Order> {\n    let url_ = this.baseUrl + '/store/order';\n    url_ = url_.replace(/[?&]$/, '');\n\n    const content_ = JSON.stringify(body);\n\n    let options_ = <AxiosRequestConfig>{\n      data: content_,\n      method: 'POST',\n      url: url_,\n      headers: {\n        'Content-Type': 'application/json',\n        Accept: 'application/json',\n      },\n      cancelToken,\n    };\n\n    return this.instance\n      .request(options_)\n      .catch((_error: any) => {\n        if (isAxiosError(_error) && _error.response) {\n          return _error.response;\n        } else {\n          throw _error;\n        }\n      })\n      .then((_response: AxiosResponse) => {\n        return this.processPlaceOrder(_response);\n      });\n  }\n\n  protected processPlaceOrder(response: AxiosResponse): Promise<Order> {\n    const status = response.status;\n    let _headers: any = {};\n    if (response.headers && typeof response.headers === 'object') {\n      for (let k in response.headers) {\n        if (response.headers.hasOwnProperty(k)) {\n          _headers[k] = response.headers[k];\n        }\n      }\n    }\n    if (status === 200) {\n      const _responseText = response.data;\n      let result200: any = null;\n      let resultData200 = _responseText;\n      result200 = Order.fromJS(resultData200);\n      return Promise.resolve<Order>(result200);\n    } else if (status === 400) {\n      const _responseText = response.data;\n      return throwException('Invalid Order', status, _responseText, _headers);\n    } else if (status !== 200 && status !== 204) {\n      const _responseText = response.data;\n      return throwException(\n        'An unexpected server error occurred.',\n        status,\n        _responseText,\n        _headers,\n      );\n    }\n    return Promise.resolve<Order>(null as any);\n  }\n\n  /**\n   * Find purchase order by ID\n   * @param orderId ID of pet that needs to be fetched\n   * @return successful operation\n   */\n  getOrderById(\n    orderId: number,\n    cancelToken?: CancelToken | undefined,\n  ): Promise<Order> {\n    let url_ = this.baseUrl + '/store/order/{orderId}';\n    if (orderId === undefined || orderId === null)\n      throw new Error(\"The parameter 'orderId' must be defined.\");\n    url_ = url_.replace('{orderId}', encodeURIComponent('' + orderId));\n    url_ = url_.replace(/[?&]$/, '');\n\n    let options_ = <AxiosRequestConfig>{\n      method: 'GET',\n      url: url_,\n      headers: {\n        Accept: 'application/json',\n      },\n      cancelToken,\n    };\n\n    return this.instance\n      .request(options_)\n      .catch((_error: any) => {\n        if (isAxiosError(_error) && _error.response) {\n          return _error.response;\n        } else {\n          throw _error;\n        }\n      })\n      .then((_response: AxiosResponse) => {\n        return this.processGetOrderById(_response);\n      });\n  }\n\n  protected processGetOrderById(response: AxiosResponse): Promise<Order> {\n    const status = response.status;\n    let _headers: any = {};\n    if (response.headers && typeof response.headers === 'object') {\n      for (let k in response.headers) {\n        if (response.headers.hasOwnProperty(k)) {\n          _headers[k] = response.headers[k];\n        }\n      }\n    }\n    if (status === 200) {\n      const _responseText = response.data;\n      let result200: any = null;\n      let resultData200 = _responseText;\n      result200 = Order.fromJS(resultData200);\n      return Promise.resolve<Order>(result200);\n    } else if (status === 400) {\n      const _responseText = response.data;\n      return throwException(\n        'Invalid ID supplied',\n        status,\n        _responseText,\n        _headers,\n      );\n    } else if (status === 404) {\n      const _responseText = response.data;\n      return throwException('Order not found', status, _responseText, _headers);\n    } else if (status !== 200 && status !== 204) {\n      const _responseText = response.data;\n      return throwException(\n        'An unexpected server error occurred.',\n        status,\n        _responseText,\n        _headers,\n      );\n    }\n    return Promise.resolve<Order>(null as any);\n  }\n\n  /**\n   * Delete purchase order by ID\n   * @param orderId ID of the order that needs to be deleted\n   */\n  deleteOrder(\n    orderId: number,\n    cancelToken?: CancelToken | undefined,\n  ): Promise<void> {\n    let url_ = this.baseUrl + '/store/order/{orderId}';\n    if (orderId === undefined || orderId === null)\n      throw new Error(\"The parameter 'orderId' must be defined.\");\n    url_ = url_.replace('{orderId}', encodeURIComponent('' + orderId));\n    url_ = url_.replace(/[?&]$/, '');\n\n    let options_ = <AxiosRequestConfig>{\n      method: 'DELETE',\n      url: url_,\n      headers: {},\n      cancelToken,\n    };\n\n    return this.instance\n      .request(options_)\n      .catch((_error: any) => {\n        if (isAxiosError(_error) && _error.response) {\n          return _error.response;\n        } else {\n          throw _error;\n        }\n      })\n      .then((_response: AxiosResponse) => {\n        return this.processDeleteOrder(_response);\n      });\n  }\n\n  protected processDeleteOrder(response: AxiosResponse): Promise<void> {\n    const status = response.status;\n    let _headers: any = {};\n    if (response.headers && typeof response.headers === 'object') {\n      for (let k in response.headers) {\n        if (response.headers.hasOwnProperty(k)) {\n          _headers[k] = response.headers[k];\n        }\n      }\n    }\n    if (status === 400) {\n      const _responseText = response.data;\n      return throwException(\n        'Invalid ID supplied',\n        status,\n        _responseText,\n        _headers,\n      );\n    } else if (status === 404) {\n      const _responseText = response.data;\n      return throwException('Order not found', status, _responseText, _headers);\n    } else if (status !== 200 && status !== 204) {\n      const _responseText = response.data;\n      return throwException(\n        'An unexpected server error occurred.',\n        status,\n        _responseText,\n        _headers,\n      );\n    }\n    return Promise.resolve<void>(null as any);\n  }\n\n  /**\n   * Returns pet inventories by status\n   * @return successful operation\n   */\n  getInventory(\n    cancelToken?: CancelToken | undefined,\n  ): Promise<{ [key: string]: number }> {\n    let url_ = this.baseUrl + '/store/inventory';\n    url_ = url_.replace(/[?&]$/, '');\n\n    let options_ = <AxiosRequestConfig>{\n      method: 'GET',\n      url: url_,\n      headers: {\n        Accept: 'application/json',\n      },\n      cancelToken,\n    };\n\n    return this.instance\n      .request(options_)\n      .catch((_error: any) => {\n        if (isAxiosError(_error) && _error.response) {\n          return _error.response;\n        } else {\n          throw _error;\n        }\n      })\n      .then((_response: AxiosResponse) => {\n        return this.processGetInventory(_response);\n      });\n  }\n\n  protected processGetInventory(\n    response: AxiosResponse,\n  ): Promise<{ [key: string]: number }> {\n    const status = response.status;\n    let _headers: any = {};\n    if (response.headers && typeof response.headers === 'object') {\n      for (let k in response.headers) {\n        if (response.headers.hasOwnProperty(k)) {\n          _headers[k] = response.headers[k];\n        }\n      }\n    }\n    if (status === 200) {\n      const _responseText = response.data;\n      let result200: any = null;\n      let resultData200 = _responseText;\n      if (resultData200) {\n        result200 = {} as any;\n        for (let key in resultData200) {\n          if (resultData200.hasOwnProperty(key))\n            (<any>result200)![key] =\n              resultData200[key] !== undefined ? resultData200[key] : <any>null;\n        }\n      } else {\n        result200 = <any>null;\n      }\n      return Promise.resolve<{ [key: string]: number }>(result200);\n    } else if (status !== 200 && status !== 204) {\n      const _responseText = response.data;\n      return throwException(\n        'An unexpected server error occurred.',\n        status,\n        _responseText,\n        _headers,\n      );\n    }\n    return Promise.resolve<{ [key: string]: number }>(null as any);\n  }\n\n  /**\n   * Creates list of users with given input array\n   * @param body List of user object\n   * @return successful operation\n   */\n  createUsersWithArrayInput(\n    body: User[],\n    cancelToken?: CancelToken | undefined,\n  ): Promise<void> {\n    let url_ = this.baseUrl + '/user/createWithArray';\n    url_ = url_.replace(/[?&]$/, '');\n\n    const content_ = JSON.stringify(body);\n\n    let options_ = <AxiosRequestConfig>{\n      data: content_,\n      method: 'POST',\n      url: url_,\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      cancelToken,\n    };\n\n    return this.instance\n      .request(options_)\n      .catch((_error: any) => {\n        if (isAxiosError(_error) && _error.response) {\n          return _error.response;\n        } else {\n          throw _error;\n        }\n      })\n      .then((_response: AxiosResponse) => {\n        return this.processCreateUsersWithArrayInput(_response);\n      });\n  }\n\n  protected processCreateUsersWithArrayInput(\n    response: AxiosResponse,\n  ): Promise<void> {\n    const status = response.status;\n    let _headers: any = {};\n    if (response.headers && typeof response.headers === 'object') {\n      for (let k in response.headers) {\n        if (response.headers.hasOwnProperty(k)) {\n          _headers[k] = response.headers[k];\n        }\n      }\n    }\n    {\n      const _responseText = response.data;\n      return Promise.resolve<void>(null as any);\n    }\n  }\n\n  /**\n   * Creates list of users with given input array\n   * @param body List of user object\n   * @return successful operation\n   */\n  createUsersWithListInput(\n    body: User[],\n    cancelToken?: CancelToken | undefined,\n  ): Promise<void> {\n    let url_ = this.baseUrl + '/user/createWithList';\n    url_ = url_.replace(/[?&]$/, '');\n\n    const content_ = JSON.stringify(body);\n\n    let options_ = <AxiosRequestConfig>{\n      data: content_,\n      method: 'POST',\n      url: url_,\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      cancelToken,\n    };\n\n    return this.instance\n      .request(options_)\n      .catch((_error: any) => {\n        if (isAxiosError(_error) && _error.response) {\n          return _error.response;\n        } else {\n          throw _error;\n        }\n      })\n      .then((_response: AxiosResponse) => {\n        return this.processCreateUsersWithListInput(_response);\n      });\n  }\n\n  protected processCreateUsersWithListInput(\n    response: AxiosResponse,\n  ): Promise<void> {\n    const status = response.status;\n    let _headers: any = {};\n    if (response.headers && typeof response.headers === 'object') {\n      for (let k in response.headers) {\n        if (response.headers.hasOwnProperty(k)) {\n          _headers[k] = response.headers[k];\n        }\n      }\n    }\n    {\n      const _responseText = response.data;\n      return Promise.resolve<void>(null as any);\n    }\n  }\n\n  /**\n   * Get user by user name\n   * @param username The name that needs to be fetched. Use user1 for testing.\n   * @return successful operation\n   */\n  getUserByName(\n    username: string,\n    cancelToken?: CancelToken | undefined,\n  ): Promise<User> {\n    let url_ = this.baseUrl + '/user/{username}';\n    if (username === undefined || username === null)\n      throw new Error(\"The parameter 'username' must be defined.\");\n    url_ = url_.replace('{username}', encodeURIComponent('' + username));\n    url_ = url_.replace(/[?&]$/, '');\n\n    let options_ = <AxiosRequestConfig>{\n      method: 'GET',\n      url: url_,\n      headers: {\n        Accept: 'application/json',\n      },\n      cancelToken,\n    };\n\n    return this.instance\n      .request(options_)\n      .catch((_error: any) => {\n        if (isAxiosError(_error) && _error.response) {\n          return _error.response;\n        } else {\n          throw _error;\n        }\n      })\n      .then((_response: AxiosResponse) => {\n        return this.processGetUserByName(_response);\n      });\n  }\n\n  protected processGetUserByName(response: AxiosResponse): Promise<User> {\n    const status = response.status;\n    let _headers: any = {};\n    if (response.headers && typeof response.headers === 'object') {\n      for (let k in response.headers) {\n        if (response.headers.hasOwnProperty(k)) {\n          _headers[k] = response.headers[k];\n        }\n      }\n    }\n    if (status === 200) {\n      const _responseText = response.data;\n      let result200: any = null;\n      let resultData200 = _responseText;\n      result200 = User.fromJS(resultData200);\n      return Promise.resolve<User>(result200);\n    } else if (status === 400) {\n      const _responseText = response.data;\n      return throwException(\n        'Invalid username supplied',\n        status,\n        _responseText,\n        _headers,\n      );\n    } else if (status === 404) {\n      const _responseText = response.data;\n      return throwException('User not found', status, _responseText, _headers);\n    } else if (status !== 200 && status !== 204) {\n      const _responseText = response.data;\n      return throwException(\n        'An unexpected server error occurred.',\n        status,\n        _responseText,\n        _headers,\n      );\n    }\n    return Promise.resolve<User>(null as any);\n  }\n\n  /**\n   * Updated user\n   * @param username name that need to be updated\n   * @param body Updated user object\n   */\n  updateUser(\n    username: string,\n    body: User,\n    cancelToken?: CancelToken | undefined,\n  ): Promise<void> {\n    let url_ = this.baseUrl + '/user/{username}';\n    if (username === undefined || username === null)\n      throw new Error(\"The parameter 'username' must be defined.\");\n    url_ = url_.replace('{username}', encodeURIComponent('' + username));\n    url_ = url_.replace(/[?&]$/, '');\n\n    const content_ = JSON.stringify(body);\n\n    let options_ = <AxiosRequestConfig>{\n      data: content_,\n      method: 'PUT',\n      url: url_,\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      cancelToken,\n    };\n\n    return this.instance\n      .request(options_)\n      .catch((_error: any) => {\n        if (isAxiosError(_error) && _error.response) {\n          return _error.response;\n        } else {\n          throw _error;\n        }\n      })\n      .then((_response: AxiosResponse) => {\n        return this.processUpdateUser(_response);\n      });\n  }\n\n  protected processUpdateUser(response: AxiosResponse): Promise<void> {\n    const status = response.status;\n    let _headers: any = {};\n    if (response.headers && typeof response.headers === 'object') {\n      for (let k in response.headers) {\n        if (response.headers.hasOwnProperty(k)) {\n          _headers[k] = response.headers[k];\n        }\n      }\n    }\n    if (status === 400) {\n      const _responseText = response.data;\n      return throwException(\n        'Invalid user supplied',\n        status,\n        _responseText,\n        _headers,\n      );\n    } else if (status === 404) {\n      const _responseText = response.data;\n      return throwException('User not found', status, _responseText, _headers);\n    } else if (status !== 200 && status !== 204) {\n      const _responseText = response.data;\n      return throwException(\n        'An unexpected server error occurred.',\n        status,\n        _responseText,\n        _headers,\n      );\n    }\n    return Promise.resolve<void>(null as any);\n  }\n\n  /**\n   * Delete user\n   * @param username The name that needs to be deleted\n   */\n  deleteUser(\n    username: string,\n    cancelToken?: CancelToken | undefined,\n  ): Promise<void> {\n    let url_ = this.baseUrl + '/user/{username}';\n    if (username === undefined || username === null)\n      throw new Error(\"The parameter 'username' must be defined.\");\n    url_ = url_.replace('{username}', encodeURIComponent('' + username));\n    url_ = url_.replace(/[?&]$/, '');\n\n    let options_ = <AxiosRequestConfig>{\n      method: 'DELETE',\n      url: url_,\n      headers: {},\n      cancelToken,\n    };\n\n    return this.instance\n      .request(options_)\n      .catch((_error: any) => {\n        if (isAxiosError(_error) && _error.response) {\n          return _error.response;\n        } else {\n          throw _error;\n        }\n      })\n      .then((_response: AxiosResponse) => {\n        return this.processDeleteUser(_response);\n      });\n  }\n\n  protected processDeleteUser(response: AxiosResponse): Promise<void> {\n    const status = response.status;\n    let _headers: any = {};\n    if (response.headers && typeof response.headers === 'object') {\n      for (let k in response.headers) {\n        if (response.headers.hasOwnProperty(k)) {\n          _headers[k] = response.headers[k];\n        }\n      }\n    }\n    if (status === 400) {\n      const _responseText = response.data;\n      return throwException(\n        'Invalid username supplied',\n        status,\n        _responseText,\n        _headers,\n      );\n    } else if (status === 404) {\n      const _responseText = response.data;\n      return throwException('User not found', status, _responseText, _headers);\n    } else if (status !== 200 && status !== 204) {\n      const _responseText = response.data;\n      return throwException(\n        'An unexpected server error occurred.',\n        status,\n        _responseText,\n        _headers,\n      );\n    }\n    return Promise.resolve<void>(null as any);\n  }\n\n  /**\n   * Logs user into the system\n   * @param username The user name for login\n   * @param password The password for login in clear text\n   * @return successful operation\n   */\n  loginUser(\n    username: string,\n    password: string,\n    cancelToken?: CancelToken | undefined,\n  ): Promise<string> {\n    let url_ = this.baseUrl + '/user/login?';\n    if (username === undefined || username === null)\n      throw new Error(\n        \"The parameter 'username' must be defined and cannot be null.\",\n      );\n    else url_ += 'username=' + encodeURIComponent('' + username) + '&';\n    if (password === undefined || password === null)\n      throw new Error(\n        \"The parameter 'password' must be defined and cannot be null.\",\n      );\n    else url_ += 'password=' + encodeURIComponent('' + password) + '&';\n    url_ = url_.replace(/[?&]$/, '');\n\n    let options_ = <AxiosRequestConfig>{\n      method: 'GET',\n      url: url_,\n      headers: {\n        Accept: 'application/json',\n      },\n      cancelToken,\n    };\n\n    return this.instance\n      .request(options_)\n      .catch((_error: any) => {\n        if (isAxiosError(_error) && _error.response) {\n          return _error.response;\n        } else {\n          throw _error;\n        }\n      })\n      .then((_response: AxiosResponse) => {\n        return this.processLoginUser(_response);\n      });\n  }\n\n  protected processLoginUser(response: AxiosResponse): Promise<string> {\n    const status = response.status;\n    let _headers: any = {};\n    if (response.headers && typeof response.headers === 'object') {\n      for (let k in response.headers) {\n        if (response.headers.hasOwnProperty(k)) {\n          _headers[k] = response.headers[k];\n        }\n      }\n    }\n    if (status === 200) {\n      const _responseText = response.data;\n      let result200: any = null;\n      let resultData200 = _responseText;\n      result200 = resultData200 !== undefined ? resultData200 : <any>null;\n\n      return Promise.resolve<string>(result200);\n    } else if (status === 400) {\n      const _responseText = response.data;\n      return throwException(\n        'Invalid username/password supplied',\n        status,\n        _responseText,\n        _headers,\n      );\n    } else if (status !== 200 && status !== 204) {\n      const _responseText = response.data;\n      return throwException(\n        'An unexpected server error occurred.',\n        status,\n        _responseText,\n        _headers,\n      );\n    }\n    return Promise.resolve<string>(null as any);\n  }\n\n  /**\n   * Logs out current logged in user session\n   * @return successful operation\n   */\n  logoutUser(cancelToken?: CancelToken | undefined): Promise<void> {\n    let url_ = this.baseUrl + '/user/logout';\n    url_ = url_.replace(/[?&]$/, '');\n\n    let options_ = <AxiosRequestConfig>{\n      method: 'GET',\n      url: url_,\n      headers: {},\n      cancelToken,\n    };\n\n    return this.instance\n      .request(options_)\n      .catch((_error: any) => {\n        if (isAxiosError(_error) && _error.response) {\n          return _error.response;\n        } else {\n          throw _error;\n        }\n      })\n      .then((_response: AxiosResponse) => {\n        return this.processLogoutUser(_response);\n      });\n  }\n\n  protected processLogoutUser(response: AxiosResponse): Promise<void> {\n    const status = response.status;\n    let _headers: any = {};\n    if (response.headers && typeof response.headers === 'object') {\n      for (let k in response.headers) {\n        if (response.headers.hasOwnProperty(k)) {\n          _headers[k] = response.headers[k];\n        }\n      }\n    }\n    {\n      const _responseText = response.data;\n      return Promise.resolve<void>(null as any);\n    }\n  }\n\n  /**\n   * Create user\n   * @param body Created user object\n   * @return successful operation\n   */\n  createUser(body: User, cancelToken?: CancelToken | undefined): Promise<void> {\n    let url_ = this.baseUrl + '/user';\n    url_ = url_.replace(/[?&]$/, '');\n\n    const content_ = JSON.stringify(body);\n\n    let options_ = <AxiosRequestConfig>{\n      data: content_,\n      method: 'POST',\n      url: url_,\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      cancelToken,\n    };\n\n    return this.instance\n      .request(options_)\n      .catch((_error: any) => {\n        if (isAxiosError(_error) && _error.response) {\n          return _error.response;\n        } else {\n          throw _error;\n        }\n      })\n      .then((_response: AxiosResponse) => {\n        return this.processCreateUser(_response);\n      });\n  }\n\n  protected processCreateUser(response: AxiosResponse): Promise<void> {\n    const status = response.status;\n    let _headers: any = {};\n    if (response.headers && typeof response.headers === 'object') {\n      for (let k in response.headers) {\n        if (response.headers.hasOwnProperty(k)) {\n          _headers[k] = response.headers[k];\n        }\n      }\n    }\n    {\n      const _responseText = response.data;\n      return Promise.resolve<void>(null as any);\n    }\n  }\n}\ntype FindPetsByStatusQueryParameters = {\n  status: Status[];\n};\n\ntype FindPetsByTagsQueryParameters = {\n  tags: string[];\n};\n\ntype GetPetByIdQueryParameters = {\n  petId: number;\n};\n\ntype GetOrderByIdQueryParameters = {\n  orderId: number;\n};\n\ntype GetUserByNameQueryParameters = {\n  username: string;\n};\n\ntype LoginUserQueryParameters = {\n  username: string;\n  password: string;\n};\n\nexport class Query {\n  get baseUrl() {\n    return getBaseUrl() ?? '' + '/v2';\n  }\n\n  static get Client() {\n    return createClient(Client);\n  }\n\n  static get Url() {\n    return new Query();\n  }\n\n  findPetsByStatus(status: Status[]): string {\n    let url_ = this.baseUrl + '/pet/findByStatus?';\n    if (status === undefined || status === null)\n      throw new Error(\n        \"The parameter 'status' must be defined and cannot be null.\",\n      );\n    else\n      status &&\n        status.forEach((item) => {\n          url_ += 'status=' + encodeURIComponent('' + item) + '&';\n        });\n    url_ = url_.replace(/[?&]$/, '');\n    return url_;\n  }\n\n  static findPetsByStatusDefaultOptions?: UseQueryOptions<\n    Pet[],\n    unknown,\n    Pet[]\n  > = {};\n  public static findPetsByStatusQueryKey(status: Status[]): QueryKey;\n  public static findPetsByStatusQueryKey(...params: any[]): QueryKey {\n    if (params.length === 1 && isParameterObject(params[0])) {\n      const { status } = params[0] as FindPetsByStatusQueryParameters;\n\n      return removeUndefinedFromArrayTail([\n        'Client',\n        'findPetsByStatus',\n        status as any,\n      ]);\n    } else {\n      return removeUndefinedFromArrayTail([\n        'Client',\n        'findPetsByStatus',\n        ...params,\n      ]);\n    }\n  }\n\n  private static findPetsByStatus(context: QueryFunctionContext) {\n    return Query.Client.findPetsByStatus(context.queryKey[2] as Status[]);\n  }\n\n  static useFindPetsByStatusQuery<TSelectData = Pet[], TError = unknown>(\n    dto: FindPetsByStatusQueryParameters,\n    options?: UseQueryOptions<Pet[], TError, TSelectData>,\n  ): UseQueryResult<TSelectData, TError>;\n  /**\n   * Finds Pets by status\n   * @param status Status values that need to be considered for filter\n   * @return successful operation\n   */\n  static useFindPetsByStatusQuery<TSelectData = Pet[], TError = unknown>(\n    status: Status[],\n    options?: UseQueryOptions<Pet[], TError, TSelectData>,\n  ): UseQueryResult<TSelectData, TError>;\n  static useFindPetsByStatusQuery<TSelectData = Pet[], TError = unknown>(\n    ...params: any[]\n  ): UseQueryResult<TSelectData, TError> {\n    let options: UseQueryOptions<Pet[], TError, TSelectData> | undefined =\n      undefined;\n    let status: any = undefined;\n\n    if (params.length > 0) {\n      if (isParameterObject(params[0])) {\n        ({ status } = params[0] as FindPetsByStatusQueryParameters);\n        options = params[1];\n      } else {\n        [status, options] = params;\n      }\n    }\n\n    const metaContext = useContext(QueryMetaContext);\n    if (metaContext.metaFn) {\n      options = options ?? {};\n      options.meta = {\n        ...metaContext.metaFn(),\n        ...options.meta,\n      };\n    }\n\n    return useQuery<Pet[], TError, TSelectData>({\n      queryFn: Query.findPetsByStatus,\n      queryKey: Query.findPetsByStatusQueryKey(status),\n      ...(Query.findPetsByStatusDefaultOptions as unknown as UseQueryOptions<\n        Pet[],\n        TError,\n        TSelectData\n      >),\n      ...options,\n    });\n  }\n  /**\n   * Finds Pets by status\n   * @param status Status values that need to be considered for filter\n   * @return successful operation\n   */\n  static setFindPetsByStatusData(\n    queryClient: QueryClient,\n    updater: (data: Pet[] | undefined) => Pet[],\n    status: Status[],\n  ) {\n    queryClient.setQueryData(Query.findPetsByStatusQueryKey(status), updater);\n  }\n\n  /**\n   * Finds Pets by status\n   * @param status Status values that need to be considered for filter\n   * @return successful operation\n   */\n  static setFindPetsByStatusDataByQueryId(\n    queryClient: QueryClient,\n    queryKey: QueryKey,\n    updater: (data: Pet[] | undefined) => Pet[],\n  ) {\n    queryClient.setQueryData(queryKey, updater);\n  }\n\n  findPetsByTags(tags: string[]): string {\n    let url_ = this.baseUrl + '/pet/findByTags?';\n    if (tags === undefined || tags === null)\n      throw new Error(\n        \"The parameter 'tags' must be defined and cannot be null.\",\n      );\n    else\n      tags &&\n        tags.forEach((item) => {\n          url_ += 'tags=' + encodeURIComponent('' + item) + '&';\n        });\n    url_ = url_.replace(/[?&]$/, '');\n    return url_;\n  }\n\n  static findPetsByTagsDefaultOptions?: UseQueryOptions<Pet[], unknown, Pet[]> =\n    {};\n  public static findPetsByTagsQueryKey(tags: string[]): QueryKey;\n  public static findPetsByTagsQueryKey(...params: any[]): QueryKey {\n    if (params.length === 1 && isParameterObject(params[0])) {\n      const { tags } = params[0] as FindPetsByTagsQueryParameters;\n\n      return removeUndefinedFromArrayTail([\n        'Client',\n        'findPetsByTags',\n        tags as any,\n      ]);\n    } else {\n      return removeUndefinedFromArrayTail([\n        'Client',\n        'findPetsByTags',\n        ...params,\n      ]);\n    }\n  }\n\n  private static findPetsByTags(context: QueryFunctionContext) {\n    return Query.Client.findPetsByTags(context.queryKey[2] as string[]);\n  }\n\n  static useFindPetsByTagsQuery<TSelectData = Pet[], TError = unknown>(\n    dto: FindPetsByTagsQueryParameters,\n    options?: UseQueryOptions<Pet[], TError, TSelectData>,\n  ): UseQueryResult<TSelectData, TError>;\n  /**\n   * Finds Pets by tags\n   * @param tags Tags to filter by\n   * @return successful operation\n   * @deprecated\n   */\n  static useFindPetsByTagsQuery<TSelectData = Pet[], TError = unknown>(\n    tags: string[],\n    options?: UseQueryOptions<Pet[], TError, TSelectData>,\n  ): UseQueryResult<TSelectData, TError>;\n  static useFindPetsByTagsQuery<TSelectData = Pet[], TError = unknown>(\n    ...params: any[]\n  ): UseQueryResult<TSelectData, TError> {\n    let options: UseQueryOptions<Pet[], TError, TSelectData> | undefined =\n      undefined;\n    let tags: any = undefined;\n\n    if (params.length > 0) {\n      if (isParameterObject(params[0])) {\n        ({ tags } = params[0] as FindPetsByTagsQueryParameters);\n        options = params[1];\n      } else {\n        [tags, options] = params;\n      }\n    }\n\n    const metaContext = useContext(QueryMetaContext);\n    if (metaContext.metaFn) {\n      options = options ?? {};\n      options.meta = {\n        ...metaContext.metaFn(),\n        ...options.meta,\n      };\n    }\n\n    return useQuery<Pet[], TError, TSelectData>({\n      queryFn: Query.findPetsByTags,\n      queryKey: Query.findPetsByTagsQueryKey(tags),\n      ...(Query.findPetsByTagsDefaultOptions as unknown as UseQueryOptions<\n        Pet[],\n        TError,\n        TSelectData\n      >),\n      ...options,\n    });\n  }\n  /**\n   * Finds Pets by tags\n   * @param tags Tags to filter by\n   * @return successful operation\n   * @deprecated\n   */\n  static setFindPetsByTagsData(\n    queryClient: QueryClient,\n    updater: (data: Pet[] | undefined) => Pet[],\n    tags: string[],\n  ) {\n    queryClient.setQueryData(Query.findPetsByTagsQueryKey(tags), updater);\n  }\n\n  /**\n   * Finds Pets by tags\n   * @param tags Tags to filter by\n   * @return successful operation\n   * @deprecated\n   */\n  static setFindPetsByTagsDataByQueryId(\n    queryClient: QueryClient,\n    queryKey: QueryKey,\n    updater: (data: Pet[] | undefined) => Pet[],\n  ) {\n    queryClient.setQueryData(queryKey, updater);\n  }\n\n  getPetById(petId: number): string {\n    let url_ = this.baseUrl + '/pet/{petId}';\n    if (petId === undefined || petId === null)\n      throw new Error(\"The parameter 'petId' must be defined.\");\n    url_ = url_.replace('{petId}', encodeURIComponent('' + petId));\n    url_ = url_.replace(/[?&]$/, '');\n    return url_;\n  }\n\n  static getPetByIdDefaultOptions?: UseQueryOptions<Pet, unknown, Pet> = {};\n  public static getPetByIdQueryKey(petId: number): QueryKey;\n  public static getPetByIdQueryKey(...params: any[]): QueryKey {\n    if (params.length === 1 && isParameterObject(params[0])) {\n      const { petId } = params[0] as GetPetByIdQueryParameters;\n\n      return removeUndefinedFromArrayTail([\n        'Client',\n        'getPetById',\n        petId as any,\n      ]);\n    } else {\n      return removeUndefinedFromArrayTail(['Client', 'getPetById', ...params]);\n    }\n  }\n\n  private static getPetById(context: QueryFunctionContext) {\n    return Query.Client.getPetById(context.queryKey[2] as number);\n  }\n\n  static useGetPetByIdQuery<TSelectData = Pet, TError = unknown>(\n    dto: GetPetByIdQueryParameters,\n    options?: UseQueryOptions<Pet, TError, TSelectData>,\n  ): UseQueryResult<TSelectData, TError>;\n  /**\n   * Find pet by ID\n   * @param petId ID of pet to return\n   * @return successful operation\n   */\n  static useGetPetByIdQuery<TSelectData = Pet, TError = unknown>(\n    petId: number,\n    options?: UseQueryOptions<Pet, TError, TSelectData>,\n  ): UseQueryResult<TSelectData, TError>;\n  static useGetPetByIdQuery<TSelectData = Pet, TError = unknown>(\n    ...params: any[]\n  ): UseQueryResult<TSelectData, TError> {\n    let options: UseQueryOptions<Pet, TError, TSelectData> | undefined =\n      undefined;\n    let petId: any = undefined;\n\n    if (params.length > 0) {\n      if (isParameterObject(params[0])) {\n        ({ petId } = params[0] as GetPetByIdQueryParameters);\n        options = params[1];\n      } else {\n        [petId, options] = params;\n      }\n    }\n\n    const metaContext = useContext(QueryMetaContext);\n    if (metaContext.metaFn) {\n      options = options ?? {};\n      options.meta = {\n        ...metaContext.metaFn(),\n        ...options.meta,\n      };\n    }\n\n    return useQuery<Pet, TError, TSelectData>({\n      queryFn: Query.getPetById,\n      queryKey: Query.getPetByIdQueryKey(petId),\n      ...(Query.getPetByIdDefaultOptions as unknown as UseQueryOptions<\n        Pet,\n        TError,\n        TSelectData\n      >),\n      ...options,\n    });\n  }\n  /**\n   * Find pet by ID\n   * @param petId ID of pet to return\n   * @return successful operation\n   */\n  static setGetPetByIdData(\n    queryClient: QueryClient,\n    updater: (data: Pet | undefined) => Pet,\n    petId: number,\n  ) {\n    queryClient.setQueryData(Query.getPetByIdQueryKey(petId), updater);\n  }\n\n  /**\n   * Find pet by ID\n   * @param petId ID of pet to return\n   * @return successful operation\n   */\n  static setGetPetByIdDataByQueryId(\n    queryClient: QueryClient,\n    queryKey: QueryKey,\n    updater: (data: Pet | undefined) => Pet,\n  ) {\n    queryClient.setQueryData(queryKey, updater);\n  }\n\n  getOrderById(orderId: number): string {\n    let url_ = this.baseUrl + '/store/order/{orderId}';\n    if (orderId === undefined || orderId === null)\n      throw new Error(\"The parameter 'orderId' must be defined.\");\n    url_ = url_.replace('{orderId}', encodeURIComponent('' + orderId));\n    url_ = url_.replace(/[?&]$/, '');\n    return url_;\n  }\n\n  static getOrderByIdDefaultOptions?: UseQueryOptions<Order, unknown, Order> =\n    {};\n  public static getOrderByIdQueryKey(orderId: number): QueryKey;\n  public static getOrderByIdQueryKey(...params: any[]): QueryKey {\n    if (params.length === 1 && isParameterObject(params[0])) {\n      const { orderId } = params[0] as GetOrderByIdQueryParameters;\n\n      return removeUndefinedFromArrayTail([\n        'Client',\n        'getOrderById',\n        orderId as any,\n      ]);\n    } else {\n      return removeUndefinedFromArrayTail([\n        'Client',\n        'getOrderById',\n        ...params,\n      ]);\n    }\n  }\n\n  private static getOrderById(context: QueryFunctionContext) {\n    return Query.Client.getOrderById(context.queryKey[2] as number);\n  }\n\n  static useGetOrderByIdQuery<TSelectData = Order, TError = unknown>(\n    dto: GetOrderByIdQueryParameters,\n    options?: UseQueryOptions<Order, TError, TSelectData>,\n  ): UseQueryResult<TSelectData, TError>;\n  /**\n   * Find purchase order by ID\n   * @param orderId ID of pet that needs to be fetched\n   * @return successful operation\n   */\n  static useGetOrderByIdQuery<TSelectData = Order, TError = unknown>(\n    orderId: number,\n    options?: UseQueryOptions<Order, TError, TSelectData>,\n  ): UseQueryResult<TSelectData, TError>;\n  static useGetOrderByIdQuery<TSelectData = Order, TError = unknown>(\n    ...params: any[]\n  ): UseQueryResult<TSelectData, TError> {\n    let options: UseQueryOptions<Order, TError, TSelectData> | undefined =\n      undefined;\n    let orderId: any = undefined;\n\n    if (params.length > 0) {\n      if (isParameterObject(params[0])) {\n        ({ orderId } = params[0] as GetOrderByIdQueryParameters);\n        options = params[1];\n      } else {\n        [orderId, options] = params;\n      }\n    }\n\n    const metaContext = useContext(QueryMetaContext);\n    if (metaContext.metaFn) {\n      options = options ?? {};\n      options.meta = {\n        ...metaContext.metaFn(),\n        ...options.meta,\n      };\n    }\n\n    return useQuery<Order, TError, TSelectData>({\n      queryFn: Query.getOrderById,\n      queryKey: Query.getOrderByIdQueryKey(orderId),\n      ...(Query.getOrderByIdDefaultOptions as unknown as UseQueryOptions<\n        Order,\n        TError,\n        TSelectData\n      >),\n      ...options,\n    });\n  }\n  /**\n   * Find purchase order by ID\n   * @param orderId ID of pet that needs to be fetched\n   * @return successful operation\n   */\n  static setGetOrderByIdData(\n    queryClient: QueryClient,\n    updater: (data: Order | undefined) => Order,\n    orderId: number,\n  ) {\n    queryClient.setQueryData(Query.getOrderByIdQueryKey(orderId), updater);\n  }\n\n  /**\n   * Find purchase order by ID\n   * @param orderId ID of pet that needs to be fetched\n   * @return successful operation\n   */\n  static setGetOrderByIdDataByQueryId(\n    queryClient: QueryClient,\n    queryKey: QueryKey,\n    updater: (data: Order | undefined) => Order,\n  ) {\n    queryClient.setQueryData(queryKey, updater);\n  }\n\n  getInventory(): string {\n    let url_ = this.baseUrl + '/store/inventory';\n    url_ = url_.replace(/[?&]$/, '');\n    return url_;\n  }\n\n  static getInventoryDefaultOptions?: UseQueryOptions<\n    { [key: string]: number },\n    unknown,\n    { [key: string]: number }\n  > = {};\n  public static getInventoryQueryKey(): QueryKey;\n  public static getInventoryQueryKey(...params: any[]): QueryKey {\n    return removeUndefinedFromArrayTail(['Client', 'getInventory']);\n  }\n\n  private static getInventory() {\n    return Query.Client.getInventory();\n  }\n\n  /**\n   * Returns pet inventories by status\n   * @return successful operation\n   */\n  static useGetInventoryQuery<\n    TSelectData = { [key: string]: number },\n    TError = unknown,\n  >(\n    options?: UseQueryOptions<{ [key: string]: number }, TError, TSelectData>,\n  ): UseQueryResult<TSelectData, TError>;\n  static useGetInventoryQuery<\n    TSelectData = { [key: string]: number },\n    TError = unknown,\n  >(...params: any[]): UseQueryResult<TSelectData, TError> {\n    let options:\n      | UseQueryOptions<{ [key: string]: number }, TError, TSelectData>\n      | undefined = undefined;\n\n    options = params[0] as any;\n\n    const metaContext = useContext(QueryMetaContext);\n    if (metaContext.metaFn) {\n      options = options ?? {};\n      options.meta = {\n        ...metaContext.metaFn(),\n        ...options.meta,\n      };\n    }\n\n    return useQuery<{ [key: string]: number }, TError, TSelectData>({\n      queryFn: Query.getInventory,\n      queryKey: Query.getInventoryQueryKey(),\n      ...(Query.getInventoryDefaultOptions as unknown as UseQueryOptions<\n        { [key: string]: number },\n        TError,\n        TSelectData\n      >),\n      ...options,\n    });\n  }\n  /**\n   * Returns pet inventories by status\n   * @return successful operation\n   */\n  static setGetInventoryData(\n    queryClient: QueryClient,\n    updater: (data: { [key: string]: number } | undefined) => {\n      [key: string]: number;\n    },\n  ) {\n    queryClient.setQueryData(Query.getInventoryQueryKey(), updater);\n  }\n\n  /**\n   * Returns pet inventories by status\n   * @return successful operation\n   */\n  static setGetInventoryDataByQueryId(\n    queryClient: QueryClient,\n    queryKey: QueryKey,\n    updater: (data: { [key: string]: number } | undefined) => {\n      [key: string]: number;\n    },\n  ) {\n    queryClient.setQueryData(queryKey, updater);\n  }\n\n  getUserByName(username: string): string {\n    let url_ = this.baseUrl + '/user/{username}';\n    if (username === undefined || username === null)\n      throw new Error(\"The parameter 'username' must be defined.\");\n    url_ = url_.replace('{username}', encodeURIComponent('' + username));\n    url_ = url_.replace(/[?&]$/, '');\n    return url_;\n  }\n\n  static getUserByNameDefaultOptions?: UseQueryOptions<User, unknown, User> =\n    {};\n  public static getUserByNameQueryKey(username: string): QueryKey;\n  public static getUserByNameQueryKey(...params: any[]): QueryKey {\n    if (params.length === 1 && isParameterObject(params[0])) {\n      const { username } = params[0] as GetUserByNameQueryParameters;\n\n      return removeUndefinedFromArrayTail([\n        'Client',\n        'getUserByName',\n        username as any,\n      ]);\n    } else {\n      return removeUndefinedFromArrayTail([\n        'Client',\n        'getUserByName',\n        ...params,\n      ]);\n    }\n  }\n\n  private static getUserByName(context: QueryFunctionContext) {\n    return Query.Client.getUserByName(context.queryKey[2] as string);\n  }\n\n  static useGetUserByNameQuery<TSelectData = User, TError = unknown>(\n    dto: GetUserByNameQueryParameters,\n    options?: UseQueryOptions<User, TError, TSelectData>,\n  ): UseQueryResult<TSelectData, TError>;\n  /**\n   * Get user by user name\n   * @param username The name that needs to be fetched. Use user1 for testing.\n   * @return successful operation\n   */\n  static useGetUserByNameQuery<TSelectData = User, TError = unknown>(\n    username: string,\n    options?: UseQueryOptions<User, TError, TSelectData>,\n  ): UseQueryResult<TSelectData, TError>;\n  static useGetUserByNameQuery<TSelectData = User, TError = unknown>(\n    ...params: any[]\n  ): UseQueryResult<TSelectData, TError> {\n    let options: UseQueryOptions<User, TError, TSelectData> | undefined =\n      undefined;\n    let username: any = undefined;\n\n    if (params.length > 0) {\n      if (isParameterObject(params[0])) {\n        ({ username } = params[0] as GetUserByNameQueryParameters);\n        options = params[1];\n      } else {\n        [username, options] = params;\n      }\n    }\n\n    const metaContext = useContext(QueryMetaContext);\n    if (metaContext.metaFn) {\n      options = options ?? {};\n      options.meta = {\n        ...metaContext.metaFn(),\n        ...options.meta,\n      };\n    }\n\n    return useQuery<User, TError, TSelectData>({\n      queryFn: Query.getUserByName,\n      queryKey: Query.getUserByNameQueryKey(username),\n      ...(Query.getUserByNameDefaultOptions as unknown as UseQueryOptions<\n        User,\n        TError,\n        TSelectData\n      >),\n      ...options,\n    });\n  }\n  /**\n   * Get user by user name\n   * @param username The name that needs to be fetched. Use user1 for testing.\n   * @return successful operation\n   */\n  static setGetUserByNameData(\n    queryClient: QueryClient,\n    updater: (data: User | undefined) => User,\n    username: string,\n  ) {\n    queryClient.setQueryData(Query.getUserByNameQueryKey(username), updater);\n  }\n\n  /**\n   * Get user by user name\n   * @param username The name that needs to be fetched. Use user1 for testing.\n   * @return successful operation\n   */\n  static setGetUserByNameDataByQueryId(\n    queryClient: QueryClient,\n    queryKey: QueryKey,\n    updater: (data: User | undefined) => User,\n  ) {\n    queryClient.setQueryData(queryKey, updater);\n  }\n\n  loginUser(username: string, password: string): string {\n    let url_ = this.baseUrl + '/user/login?';\n    if (username === undefined || username === null)\n      throw new Error(\n        \"The parameter 'username' must be defined and cannot be null.\",\n      );\n    else url_ += 'username=' + encodeURIComponent('' + username) + '&';\n    if (password === undefined || password === null)\n      throw new Error(\n        \"The parameter 'password' must be defined and cannot be null.\",\n      );\n    else url_ += 'password=' + encodeURIComponent('' + password) + '&';\n    url_ = url_.replace(/[?&]$/, '');\n    return url_;\n  }\n\n  static loginUserDefaultOptions?: UseQueryOptions<string, unknown, string> =\n    {};\n  public static loginUserQueryKey(dto: LoginUserQueryParameters): QueryKey;\n  public static loginUserQueryKey(username: string, password: string): QueryKey;\n  public static loginUserQueryKey(...params: any[]): QueryKey {\n    if (params.length === 1 && isParameterObject(params[0])) {\n      const { username, password } = params[0] as LoginUserQueryParameters;\n\n      return removeUndefinedFromArrayTail([\n        'Client',\n        'loginUser',\n        username as any,\n        password as any,\n      ]);\n    } else {\n      return removeUndefinedFromArrayTail(['Client', 'loginUser', ...params]);\n    }\n  }\n\n  private static loginUser(context: QueryFunctionContext) {\n    return Query.Client.loginUser(\n      context.queryKey[2] as string,\n      context.queryKey[3] as string,\n    );\n  }\n\n  static useLoginUserQuery<TSelectData = string, TError = unknown>(\n    dto: LoginUserQueryParameters,\n    options?: UseQueryOptions<string, TError, TSelectData>,\n  ): UseQueryResult<TSelectData, TError>;\n  /**\n   * Logs user into the system\n   * @param username The user name for login\n   * @param password The password for login in clear text\n   * @return successful operation\n   */\n  static useLoginUserQuery<TSelectData = string, TError = unknown>(\n    username: string,\n    password: string,\n    options?: UseQueryOptions<string, TError, TSelectData>,\n  ): UseQueryResult<TSelectData, TError>;\n  static useLoginUserQuery<TSelectData = string, TError = unknown>(\n    ...params: any[]\n  ): UseQueryResult<TSelectData, TError> {\n    let options: UseQueryOptions<string, TError, TSelectData> | undefined =\n      undefined;\n    let username: any = undefined;\n    let password: any = undefined;\n\n    if (params.length > 0) {\n      if (isParameterObject(params[0])) {\n        ({ username, password } = params[0] as LoginUserQueryParameters);\n        options = params[1];\n      } else {\n        [username, password, options] = params;\n      }\n    }\n\n    const metaContext = useContext(QueryMetaContext);\n    if (metaContext.metaFn) {\n      options = options ?? {};\n      options.meta = {\n        ...metaContext.metaFn(),\n        ...options.meta,\n      };\n    }\n\n    return useQuery<string, TError, TSelectData>({\n      queryFn: Query.loginUser,\n      queryKey: Query.loginUserQueryKey(username, password),\n      ...(Query.loginUserDefaultOptions as unknown as UseQueryOptions<\n        string,\n        TError,\n        TSelectData\n      >),\n      ...options,\n    });\n  }\n  /**\n   * Logs user into the system\n   * @param username The user name for login\n   * @param password The password for login in clear text\n   * @return successful operation\n   */\n  static setLoginUserData(\n    queryClient: QueryClient,\n    updater: (data: string | undefined) => string,\n    username: string,\n    password: string,\n  ) {\n    queryClient.setQueryData(\n      Query.loginUserQueryKey(username, password),\n      updater,\n    );\n  }\n\n  /**\n   * Logs user into the system\n   * @param username The user name for login\n   * @param password The password for login in clear text\n   * @return successful operation\n   */\n  static setLoginUserDataByQueryId(\n    queryClient: QueryClient,\n    queryKey: QueryKey,\n    updater: (data: string | undefined) => string,\n  ) {\n    queryClient.setQueryData(queryKey, updater);\n  }\n\n  logoutUser(): string {\n    let url_ = this.baseUrl + '/user/logout';\n    url_ = url_.replace(/[?&]$/, '');\n    return url_;\n  }\n\n  static logoutUserDefaultOptions?: UseQueryOptions<void, unknown, void> = {};\n  public static logoutUserQueryKey(): QueryKey;\n  public static logoutUserQueryKey(...params: any[]): QueryKey {\n    return removeUndefinedFromArrayTail(['Client', 'logoutUser']);\n  }\n\n  private static logoutUser() {\n    return Query.Client.logoutUser();\n  }\n\n  /**\n   * Logs out current logged in user session\n   * @return successful operation\n   */\n  static useLogoutUserQuery<TSelectData = void, TError = unknown>(\n    options?: UseQueryOptions<void, TError, TSelectData>,\n  ): UseQueryResult<TSelectData, TError>;\n  static useLogoutUserQuery<TSelectData = void, TError = unknown>(\n    ...params: any[]\n  ): UseQueryResult<TSelectData, TError> {\n    let options: UseQueryOptions<void, TError, TSelectData> | undefined =\n      undefined;\n\n    options = params[0] as any;\n\n    const metaContext = useContext(QueryMetaContext);\n    if (metaContext.metaFn) {\n      options = options ?? {};\n      options.meta = {\n        ...metaContext.metaFn(),\n        ...options.meta,\n      };\n    }\n\n    return useQuery<void, TError, TSelectData>({\n      queryFn: Query.logoutUser,\n      queryKey: Query.logoutUserQueryKey(),\n      ...(Query.logoutUserDefaultOptions as unknown as UseQueryOptions<\n        void,\n        TError,\n        TSelectData\n      >),\n      ...options,\n    });\n  }\n  /**\n   * Logs out current logged in user session\n   * @return successful operation\n   */\n  static setLogoutUserData(\n    queryClient: QueryClient,\n    updater: (data: void | undefined) => void,\n  ) {\n    queryClient.setQueryData(Query.logoutUserQueryKey(), updater);\n  }\n\n  /**\n   * Logs out current logged in user session\n   * @return successful operation\n   */\n  static setLogoutUserDataByQueryId(\n    queryClient: QueryClient,\n    queryKey: QueryKey,\n    updater: (data: void | undefined) => void,\n  ) {\n    queryClient.setQueryData(queryKey, updater);\n  }\n}\nresultTypesByQueryKey['Client___findPetsByStatus'] = () => new Pet();\nresultTypesByQueryKey['Client___findPetsByTags'] = () => new Pet();\nresultTypesByQueryKey['Client___getPetById'] = () => new Pet();\nresultTypesByQueryKey['Client___getOrderById'] = () => new Order();\nresultTypesByQueryKey['Client___getUserByName'] = () => new User();\n\nexport class ApiResponse implements IApiResponse {\n  code?: number | undefined;\n  type?: string | undefined;\n  message?: string | undefined;\n\n  constructor(data?: IApiResponse) {\n    if (data) {\n      for (var property in data) {\n        if (data.hasOwnProperty(property))\n          (<any>this)[property] = (<any>data)[property];\n      }\n    }\n  }\n\n  init(_data?: any) {\n    if (_data) {\n      this.code = _data['code'];\n      this.type = _data['type'];\n      this.message = _data['message'];\n    }\n  }\n\n  static fromJS(data: any): ApiResponse {\n    data = typeof data === 'object' ? data : {};\n    let result = new ApiResponse();\n    result.init(data);\n    return result;\n  }\n\n  toJSON(data?: any) {\n    data = typeof data === 'object' ? data : {};\n    data['code'] = this.code;\n    data['type'] = this.type;\n    data['message'] = this.message;\n    return data;\n  }\n}\n\nexport interface IApiResponse {\n  code?: number | undefined;\n  type?: string | undefined;\n  message?: string | undefined;\n}\n\nexport class Category implements ICategory {\n  id?: number | undefined;\n  name?: string | undefined;\n\n  constructor(data?: ICategory) {\n    if (data) {\n      for (var property in data) {\n        if (data.hasOwnProperty(property))\n          (<any>this)[property] = (<any>data)[property];\n      }\n    }\n  }\n\n  init(_data?: any) {\n    if (_data) {\n      this.id = _data['id'];\n      this.name = _data['name'];\n    }\n  }\n\n  static fromJS(data: any): Category {\n    data = typeof data === 'object' ? data : {};\n    let result = new Category();\n    result.init(data);\n    return result;\n  }\n\n  toJSON(data?: any) {\n    data = typeof data === 'object' ? data : {};\n    data['id'] = this.id;\n    data['name'] = this.name;\n    return data;\n  }\n}\n\nexport interface ICategory {\n  id?: number | undefined;\n  name?: string | undefined;\n}\n\nexport class Pet implements IPet {\n  id?: number | undefined;\n  category?: Category | undefined;\n  name!: string;\n  photoUrls!: string[];\n  tags?: Tag[] | undefined;\n  /** pet status in the store */\n  status?: PetStatus | undefined;\n\n  constructor(data?: IPet) {\n    if (data) {\n      for (var property in data) {\n        if (data.hasOwnProperty(property))\n          (<any>this)[property] = (<any>data)[property];\n      }\n    }\n    if (!data) {\n      this.photoUrls = [];\n    }\n  }\n\n  init(_data?: any) {\n    if (_data) {\n      this.id = _data['id'];\n      this.category = _data['category']\n        ? Category.fromJS(_data['category'])\n        : <any>undefined;\n      this.name = _data['name'];\n      if (Array.isArray(_data['photoUrls'])) {\n        this.photoUrls = [] as any;\n        for (let item of _data['photoUrls']) this.photoUrls!.push(item);\n      }\n      if (Array.isArray(_data['tags'])) {\n        this.tags = [] as any;\n        for (let item of _data['tags']) this.tags!.push(Tag.fromJS(item));\n      }\n      this.status = _data['status'];\n    }\n  }\n\n  static fromJS(data: any): Pet {\n    data = typeof data === 'object' ? data : {};\n    let result = new Pet();\n    result.init(data);\n    return result;\n  }\n\n  toJSON(data?: any) {\n    data = typeof data === 'object' ? data : {};\n    data['id'] = this.id;\n    data['category'] = this.category ? this.category.toJSON() : <any>undefined;\n    data['name'] = this.name;\n    if (Array.isArray(this.photoUrls)) {\n      data['photoUrls'] = [];\n      for (let item of this.photoUrls) data['photoUrls'].push(item);\n    }\n    if (Array.isArray(this.tags)) {\n      data['tags'] = [];\n      for (let item of this.tags) data['tags'].push(item.toJSON());\n    }\n    data['status'] = this.status;\n    return data;\n  }\n}\n\nexport interface IPet {\n  id?: number | undefined;\n  category?: Category | undefined;\n  name: string;\n  photoUrls: string[];\n  tags?: Tag[] | undefined;\n  /** pet status in the store */\n  status?: PetStatus | undefined;\n}\n\nexport class Tag implements ITag {\n  id?: number | undefined;\n  name?: string | undefined;\n\n  constructor(data?: ITag) {\n    if (data) {\n      for (var property in data) {\n        if (data.hasOwnProperty(property))\n          (<any>this)[property] = (<any>data)[property];\n      }\n    }\n  }\n\n  init(_data?: any) {\n    if (_data) {\n      this.id = _data['id'];\n      this.name = _data['name'];\n    }\n  }\n\n  static fromJS(data: any): Tag {\n    data = typeof data === 'object' ? data : {};\n    let result = new Tag();\n    result.init(data);\n    return result;\n  }\n\n  toJSON(data?: any) {\n    data = typeof data === 'object' ? data : {};\n    data['id'] = this.id;\n    data['name'] = this.name;\n    return data;\n  }\n}\n\nexport interface ITag {\n  id?: number | undefined;\n  name?: string | undefined;\n}\n\nexport class Order implements IOrder {\n  id?: number | undefined;\n  petId?: number | undefined;\n  quantity?: number | undefined;\n  shipDate?: Date | undefined;\n  /** Order Status */\n  status?: OrderStatus | undefined;\n  complete?: boolean | undefined;\n\n  constructor(data?: IOrder) {\n    if (data) {\n      for (var property in data) {\n        if (data.hasOwnProperty(property))\n          (<any>this)[property] = (<any>data)[property];\n      }\n    }\n  }\n\n  init(_data?: any) {\n    if (_data) {\n      this.id = _data['id'];\n      this.petId = _data['petId'];\n      this.quantity = _data['quantity'];\n      this.shipDate = _data['shipDate']\n        ? new Date(_data['shipDate'].toString())\n        : <any>undefined;\n      this.status = _data['status'];\n      this.complete = _data['complete'];\n    }\n  }\n\n  static fromJS(data: any): Order {\n    data = typeof data === 'object' ? data : {};\n    let result = new Order();\n    result.init(data);\n    return result;\n  }\n\n  toJSON(data?: any) {\n    data = typeof data === 'object' ? data : {};\n    data['id'] = this.id;\n    data['petId'] = this.petId;\n    data['quantity'] = this.quantity;\n    data['shipDate'] = this.shipDate\n      ? this.shipDate.toISOString()\n      : <any>undefined;\n    data['status'] = this.status;\n    data['complete'] = this.complete;\n    return data;\n  }\n}\n\nexport interface IOrder {\n  id?: number | undefined;\n  petId?: number | undefined;\n  quantity?: number | undefined;\n  shipDate?: Date | undefined;\n  /** Order Status */\n  status?: OrderStatus | undefined;\n  complete?: boolean | undefined;\n}\n\nexport class User implements IUser {\n  id?: number | undefined;\n  username?: string | undefined;\n  firstName?: string | undefined;\n  lastName?: string | undefined;\n  email?: string | undefined;\n  password?: string | undefined;\n  phone?: string | undefined;\n  /** User Status */\n  userStatus?: number | undefined;\n\n  constructor(data?: IUser) {\n    if (data) {\n      for (var property in data) {\n        if (data.hasOwnProperty(property))\n          (<any>this)[property] = (<any>data)[property];\n      }\n    }\n  }\n\n  init(_data?: any) {\n    if (_data) {\n      this.id = _data['id'];\n      this.username = _data['username'];\n      this.firstName = _data['firstName'];\n      this.lastName = _data['lastName'];\n      this.email = _data['email'];\n      this.password = _data['password'];\n      this.phone = _data['phone'];\n      this.userStatus = _data['userStatus'];\n    }\n  }\n\n  static fromJS(data: any): User {\n    data = typeof data === 'object' ? data : {};\n    let result = new User();\n    result.init(data);\n    return result;\n  }\n\n  toJSON(data?: any) {\n    data = typeof data === 'object' ? data : {};\n    data['id'] = this.id;\n    data['username'] = this.username;\n    data['firstName'] = this.firstName;\n    data['lastName'] = this.lastName;\n    data['email'] = this.email;\n    data['password'] = this.password;\n    data['phone'] = this.phone;\n    data['userStatus'] = this.userStatus;\n    return data;\n  }\n}\n\nexport interface IUser {\n  id?: number | undefined;\n  username?: string | undefined;\n  firstName?: string | undefined;\n  lastName?: string | undefined;\n  email?: string | undefined;\n  password?: string | undefined;\n  phone?: string | undefined;\n  /** User Status */\n  userStatus?: number | undefined;\n}\n\nexport enum Status {\n  Available = 'available',\n  Pending = 'pending',\n  Sold = 'sold',\n}\n\nexport enum PetStatus {\n  Available = 'available',\n  Pending = 'pending',\n  Sold = 'sold',\n}\n\nexport enum OrderStatus {\n  Placed = 'placed',\n  Approved = 'approved',\n  Delivered = 'delivered',\n}\n\nexport interface FileParameter {\n  data: any;\n  fileName: string;\n}\n\nexport class ApiException extends Error {\n  message: string;\n  status: number;\n  response: string;\n  headers: { [key: string]: any };\n  result: any;\n\n  constructor(\n    message: string,\n    status: number,\n    response: string,\n    headers: { [key: string]: any },\n    result: any,\n  ) {\n    super();\n\n    this.message = message;\n    this.status = status;\n    this.response = response;\n    this.headers = headers;\n    this.result = result;\n  }\n\n  protected isApiException = true;\n\n  static isApiException(obj: any): obj is ApiException {\n    return obj.isApiException === true;\n  }\n}\n\nfunction throwException(\n  message: string,\n  status: number,\n  response: string,\n  headers: { [key: string]: any },\n  result?: any,\n): any {\n  if (result !== null && result !== undefined) throw result;\n  else throw new ApiException(message, status, response, headers, null);\n}\n\nfunction isAxiosError(obj: any | undefined): obj is AxiosError {\n  return obj && obj.isAxiosError === true;\n}\n\nimport {\n  useQuery,\n  UseQueryResult,\n  QueryFunctionContext,\n  UseQueryOptions,\n  QueryClient,\n  QueryKey,\n} from 'react-query';\nimport { QueryMetaContext } from 'react-query-swagger';\nimport { useContext } from 'react';\nimport { PersistedClient } from 'react-query/persistQueryClient-experimental';\n\nfunction removeUndefinedFromArrayTail<T>(arr: T[]): T[] {\n  let lastDefinedValueIndex = arr.length - 1;\n  while (lastDefinedValueIndex >= 0) {\n    if (arr[lastDefinedValueIndex] === undefined) {\n      lastDefinedValueIndex--;\n    } else {\n      break;\n    }\n  }\n  return lastDefinedValueIndex === arr.length - 1\n    ? arr\n    : arr.slice(0, lastDefinedValueIndex + 1);\n}\n\n/*\n  Determines if first parameter of useSomethingQuery is an object with query parameters, or it's a regular parameter\n  Returns true if parameter is Object\n  Returns false if parameter is number/string/boolean/Date or Array\n*/\nfunction isParameterObject(param: unknown) {\n  if (param === null || param === undefined) return false;\n  if (param instanceof Array) return false;\n  const isObject = typeof param === 'object';\n  if (!isObject) return false;\n  if (param instanceof Date) return false;\n  return true;\n}\n\ntype ClientFactoryFunction = <T>(type: new (...params: any[]) => T) => T;\nlet _clientFactoryFunction: ClientFactoryFunction = <T>(\n  type: new (...params: any[]) => T,\n) => {\n  const params = [_baseUrl, _axiosFactory()];\n  return new type(...params);\n};\n/*\n  Overrides default Client factory function\n*/\nexport function setClientFactory(value: ClientFactoryFunction) {\n  _clientFactoryFunction = value;\n}\n\n/*\n  Returns current Client factory function\n*/\nexport function getClientFactory() {\n  return _clientFactoryFunction;\n}\n\n/*\n  Function that will be called from `useQuery...` methods to get a client of certain type\n*/\nfunction createClient<T>(type: new () => T) {\n  return _clientFactoryFunction(type);\n}\n\nlet _baseUrl = '';\n/*\n  Returns the base URL for http requests\n*/\nexport function getBaseUrl(): string {\n  return _baseUrl;\n}\n\n/*\n  Sets the base URL for http requests\n*/\nexport function setBaseUrl(baseUrl: string) {\n  _baseUrl = baseUrl;\n}\n\nlet _axiosFactory: () => AxiosInstance | undefined = () => undefined;\n/*\n  Returns currently used factory for Axios instances\n*/\nexport function getAxiosFactory() {\n  return _axiosFactory;\n}\n/*\n  Sets the factory for Axios instances\n*/\nexport function setAxiosFactory(factory: () => AxiosInstance) {\n  _axiosFactory = factory;\n}\n\nfunction parseDateOnly(s: string) {\n  const date = new Date(s);\n  return new Date(date.getTime() + date.getTimezoneOffset() * 60000);\n}\nexport function persistorDeserialize(cache: string): PersistedClient {\n  const client: PersistedClient = JSON.parse(cache);\n\n  client.clientState.queries.forEach((query) => {\n    const data: any = query.state.data;\n\n    if (Array.isArray(data)) {\n      query.state.data = data.map((elem) =>\n        constructDtoClass(query.queryKey, elem),\n      );\n    } else {\n      query.state.data = constructDtoClass(query.queryKey, data);\n    }\n  });\n\n  return client;\n}\n\nfunction constructDtoClass(queryKey: QueryKey, data: any): unknown {\n  const resultTypeKey = getResultTypeClassKey(queryKey);\n  const constructorFunction = resultTypesByQueryKey[resultTypeKey];\n\n  if (!constructorFunction) {\n    return data;\n  }\n\n  const dto = constructorFunction();\n  dto.init(data);\n\n  return dto;\n}\n\nfunction getResultTypeClassKey(queryKey: QueryKey): string {\n  if (!Array.isArray(queryKey)) {\n    return queryKey as string;\n  }\n  if (queryKey.length >= 2) {\n    // We concatenate first and second elements, because they uniquely identify the query.\n    // All other QueryKey elements are query parameters\n    return `${queryKey[0]}___${queryKey[1]}`;\n  }\n\n  // We actually should never reach this point :)\n  return queryKey.join('___');\n}\n","C:\\Work\\react-query-swagger\\examples\\pet-client\\src\\reportWebVitals.ts",["46"],"import { ReportHandler } from 'web-vitals';\r\n\r\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\r\n  if (onPerfEntry && onPerfEntry instanceof Function) {\r\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\r\n      getCLS(onPerfEntry);\r\n      getFID(onPerfEntry);\r\n      getFCP(onPerfEntry);\r\n      getLCP(onPerfEntry);\r\n      getTTFB(onPerfEntry);\r\n    });\r\n  }\r\n};\r\n\r\nexport default reportWebVitals;\r\n","C:\\Work\\react-query-swagger\\examples\\pet-client\\src\\components\\PetsList.tsx",["47"],"import { AxiosQuery } from '../api';\nimport { Status } from '../api/axios-client';\nimport React from 'react';\n\nexport const PetsList = () => {\n  const pets1Query = AxiosQuery.Query.useFindPetsByStatusQuery({\n    status: [Status.Pending, Status.Sold],\n  });\n  return (\n    <div>\n      <h1>List:</h1>\n      <ol>\n        {pets1Query.data?.map((pet, index) => (\n          <li key={index}>{pet.name}</li>\n        ))}\n      </ol>\n    </div>\n  );\n};\n",[],{"ruleId":"48","severity":2,"message":"49","line":1,"column":37,"nodeType":null,"messageId":"50","endLine":4,"endColumn":4,"fix":"51"},{"ruleId":"52","severity":1,"message":"53","line":3,"column":22,"nodeType":"54","messageId":"55","endLine":3,"endColumn":25,"suggestions":"56"},{"ruleId":"57","severity":1,"message":"58","line":5,"column":10,"nodeType":"59","messageId":"60","endLine":5,"endColumn":18},{"ruleId":"57","severity":1,"message":"61","line":6,"column":10,"nodeType":"59","messageId":"60","endLine":6,"endColumn":27},{"ruleId":"57","severity":1,"message":"62","line":6,"column":29,"nodeType":"59","messageId":"60","endLine":6,"endColumn":45},{"ruleId":"63","severity":1,"message":"64","line":9,"column":1,"nodeType":"65","messageId":"66","endLine":9,"endColumn":15},{"ruleId":"57","severity":1,"message":"67","line":102,"column":7,"nodeType":"59","messageId":"60","endLine":102,"endColumn":12},{"ruleId":"57","severity":1,"message":"68","line":103,"column":7,"nodeType":"59","messageId":"60","endLine":103,"endColumn":12},{"ruleId":"48","severity":2,"message":"49","line":1,"column":37,"nodeType":null,"messageId":"50","endLine":4,"endColumn":4,"fix":"69"},{"ruleId":"52","severity":1,"message":"53","line":3,"column":22,"nodeType":"54","messageId":"55","endLine":3,"endColumn":25,"suggestions":"70"},{"ruleId":"63","severity":1,"message":"64","line":3,"column":25,"nodeType":"71","messageId":"66","endLine":3,"endColumn":57},{"ruleId":"63","severity":1,"message":"64","line":5,"column":25,"nodeType":"71","messageId":"66","endLine":5,"endColumn":30},"prettier/prettier","Replace `string,()=>{init(data:any):void}>=` with `string,()=>{init(data:any):void}>=`","replace",{"range":"72","text":"73"},"@typescript-eslint/no-explicit-any","Unexpected any. Specify a different type.","TSAnyKeyword","unexpectedAny",["74","75"],"@typescript-eslint/no-unused-vars","'PetsList' is defined but never used.","Identifier","unusedVar","'QueryMetaProvider' is defined but never used.","'QueryMetaContext' is defined but never used.","@typescript-eslint/explicit-module-boundary-types","Missing return type on function.","FunctionDeclaration","missingReturnType","'meta1' is assigned a value but never used.","'meta2' is assigned a value but never used.",{"range":"76","text":"73"},["77","78"],"ArrowFunctionExpression",[36,84],"string, () => { init(data: any): void }> =\n ",{"messageId":"79","fix":"80","desc":"81"},{"messageId":"82","fix":"83","desc":"84"},[36,84],{"messageId":"79","fix":"85","desc":"81"},{"messageId":"82","fix":"86","desc":"84"},"suggestUnknown",{"range":"87","text":"88"},"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct.","suggestNever",{"range":"87","text":"89"},"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of.",{"range":"90","text":"88"},{"range":"90","text":"89"},[68,71],"unknown","never",[68,71]]